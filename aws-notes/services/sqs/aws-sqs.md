# Amazon SQS

## 概要

**フルマネージド型のメッセージキューサービス**
- サーバーを立てずに、アプリケーション間でメッセージを非同期的にやり取りできる

**疎結合なシステム設計を実現**
- 送信側（Producer）と受信側（Consumer）が直接やり取りせず、キューを介して連携

## 主な特徴

| 特徴 | 説明 |
|------|------|
| **スケーラブル** | 大量のメッセージを処理できる（毎秒数十万件以上でも対応） |
| **高可用性** | AWSインフラ上で自動的に冗長化 |
| **セキュア** | IAMポリシーやKMSによる暗号化サポート |
| **安価** | 従量課金（1,000,000リクエストあたり数十円） |

## SQSのキュータイプ

### 標準キュー（Standard Queue）
- **順序保証なし**
- **少なくとも1回配信**（同じメッセージが重複して届く可能性あり）
- **高スループット**

### FIFOキュー（First-In-First-Out Queue）
- **順序保証あり**
- **1回だけ配信**（重複排除）
- **スループットは標準より低い**（バッチ処理で最大3,000TPS）

## メッセージの流れ

### 1. Producer が送信
- `SendMessage` でキューに格納

### 2. SQS が一時保持
- メッセージは冗長化されて複数の AZ に保存

### 3. Consumer が受信
- `ReceiveMessage` で取得
- 可視性タイムアウト（Visibility Timeout）が経過すると、処理されなかった場合に再配信される

### 4. 削除
- 処理が完了したら `DeleteMessage` で削除

## 代表的な利用シーン

### マイクロサービス間の非同期通信
- **例**: 注文受付サービス → 支払い処理サービス

### バースト処理の吸収
- 一時的にリクエストが急増しても、キューがバッファになる

### 遅延処理
- `DelaySeconds` を指定して数秒〜数分後に処理

## 他のAWSサービスとの連携

- **Lambda**: SQSキューをトリガーにして自動処理
- **SNS**: Pub/Subモデルでメッセージを配信、SQSをサブスクライバーに
- **ECS / EC2**: ワーカーを並列稼働させてバッチ処理
- **EventBridge**: イベント駆動型の設計に統合

## 可視性タイムアウト（Visibility Timeout）

### 概要
Consumer（受信側）がメッセージを受信したあと、そのメッセージを他の Consumer から見えなくする時間

- **デフォルト**: 30秒
- **設定可能範囲**: 0〜12時間

### 仕組みの流れ

1. **Producer がメッセージを送信** → キューに入る
2. **Consumer が ReceiveMessage**
   - この時点でメッセージは「取得済み」状態になる
3. **Visibility Timeout が発動**
   - 設定された時間の間、そのメッセージは他の Consumer から見えない（重複処理を防ぐ）
4. **Consumer が処理完了し DeleteMessage**
   - メッセージはキューから完全に削除される
5. **もし Delete されなかった場合**（エラーやタイムアウトで処理が終わらないなど）
   - Timeout 終了後、メッセージは再び「可視化」され、別の Consumer が処理できるようになる

### 設定例（可視性タイムアウト = 30秒）

```
Consumer A がメッセージを受信
→ 30秒間は Consumer B には見えない

Consumer A が25秒以内に Delete すれば問題なし

もし処理が30秒を超えてしまったら
→ 31秒目から Consumer B も同じメッセージを受け取れる
```

### 設定のポイント

**可視性タイムアウトは「処理の猶予時間」**

- **処理時間より短いと** → 重複処理が増える
- **処理時間より長すぎると** → 失敗時の再処理が遅れる

## Producer と Consumer

### Producer とは

**Producer = メッセージを送信する側のアプリケーションやサービス**

#### 例
- EC サイトの注文システム
- IoT デバイスからのデータ送信
- Lambda 関数
- EC2 上のアプリ

> **重要**: SQS 自体は Producer ではない  
> SQS はあくまで「メッセージを一時的に預かるストレージ（キュー）」

### Consumer とは

**Consumer = メッセージを受信して処理する側のアプリケーションやサービス**

#### 例
- 注文処理システム
- 分析バッチ
- Lambda 関数
- ECS タスク

#### Consumer の特徴
- **複数存在可能**（同じキューを複数の Worker で処理する）
- スケールさせる場合は「Consumer を増やす」ことで処理能力を向上

> **重要**: SQS 自体は Consumer ではなく、ただの「中継地点」

### Consumer の並列処理

複数の Consumer を同じキューに接続することが可能

```
Producer(注文API) → [ SQSキュー ] → Consumer群(処理Worker1, Worker2, Worker3…)
```

- メッセージはキューに入ったあと、誰か1つの Consumer が取得して処理
- **例**: ECS のタスクを10台動かして同じ SQS を監視し、受信したら並列処理

### まとめ

| 役割 | 説明 | 例 |
|------|------|-----|
| **Producer** | SQS にメッセージを送る「送信側アプリ」 | Lambda, EC2, マイクロサービス |
| **Consumer** | SQS からメッセージを受け取って処理する「受信側アプリ」 | Lambda, ECS, EC2 |
| **SQS** | Producer でも Consumer でもない「中継地点」 | メッセージキューサービス |

- Producer は SQS に「投げるだけ」
- SQS は一時的に「保管するだけ」
- Consumer が「取り出して処理する」
- Consumer は複数いて OK（スケーラブル設計が可能）

## SQS の利点

### スパイク吸収
一度に大量のリクエストが来ても、SQS がバッファになるので EC2 や DynamoDB に負荷を直接かけない

### 疎結合化
Producer（Lambda）が落ちても、Consumer（EC2など）が落ちても、SQS が間を取り持つのでデータは失われにくい

### 再処理可能
Consumer が失敗しても、Visibility Timeout 後に再度別の Consumer が処理できる

## 配信遅延（Delay Delivery）

### 概要
メッセージを送信しても、すぐに Consumer から受け取れないようにする仕組み

指定した遅延時間が経過するまで、メッセージはキュー内に「不可視状態」で保持される

### 遅延の設定方法

#### キュー全体のデフォルト遅延
- `DelaySeconds`（0〜900秒＝最大15分）を設定
- そのキューに入るすべてのメッセージが対象

#### 個別メッセージごとの遅延
- `SendMessage` のときに `DelaySeconds` を指定可能
- キューのデフォルトより個別設定が優先される

### 動作例
```
DelaySeconds = 60 を指定して送信
→ Producer が送信してから 60秒間は Consumer に見えない
→ 61秒目から Consumer が受信できる
```

### ユースケース

#### リトライ処理の制御
失敗したジョブをすぐ再実行するのではなく、数分後に再試行させたい

#### 処理タイミングをずらす
**例**: バッチ処理は一定時間後にまとめて動かしたい

#### スロットリング
Consumer が一気に負荷を受けないように、メッセージを遅延投入する

### まとめ
- **配信遅延（Delay）** = 「送信から一定時間は Consumer に見せない」機能
- キュー全体（最大15分）またはメッセージ単位で設定可能
- バースト吸収や再試行間隔の調整に便利

## メッセージ保持期間（Message Retention Period）

### 概要
SQS に入ったメッセージを、削除されないまま保持しておける最大の時間

- **デフォルト**: 4日間
- **設定可能範囲**: 1分〜14日間

### 仕組み

1. **Producer がメッセージを送信**
2. **Consumer が受信して削除**（DeleteMessage）すれば保持期間は関係なし
3. **もし誰も処理せず放置した場合** → 保持期間を過ぎると自動的に削除される

### 設定のポイント

| 設定 | メリット | デメリット |
|------|----------|------------|
| **短め** | ストレージコスト削減 | 処理されないまま消えるリスク |
| **長め** | 処理の余裕があり安全 | 失敗したメッセージが溜まる可能性 |

> **推奨**: 通常は数日〜1週間程度に設定し、確実に処理されるように設計する

### ユースケース

#### 短め（数分〜数時間）
確実にすぐ処理される前提のジョブ（リアルタイム性が高いシステム）

#### 長め（数日〜1週間）
処理の遅延や障害を考慮して、再処理できる余裕を残したい場合

### まとめ
- **メッセージ保持期間** = 「SQS が未削除メッセージを保管する最大期間」
- デフォルト4日、最大14日
- 保持期間を過ぎたら自動削除され、復旧不能

## メッセージ受信待機時間（ロングポーリング）

### 概要
Consumer が SQS からメッセージを受信するときに、メッセージが無ければどれくらい待つかを指定する時間

**通称**: ロングポーリング（Long Polling）の設定

### 仕組み

`ReceiveMessage` API で SQS に問い合わせるとき、すぐに返す（ショートポーリング）か、一定時間待ってから返す（ロングポーリング）かを決められる

- **待機時間の範囲**: 0〜20秒
- **0秒** → 即時応答（メッセージがなくてもすぐレスポンス）
- **20秒** → メッセージが来るまで最大20秒待ってからレスポンス

### ロングポーリングのメリット

| メリット | 説明 |
|----------|------|
| **無駄なAPIリクエストを減らせる** | メッセージが無いのに何度も問い合わせる必要がなくなる |
| **コスト削減** | リクエスト回数課金なので、無駄なリクエストを減らせる |
| **処理遅延が減る** | 新しいメッセージが到着した瞬間に取得できる |

### 設定方法

#### キュー単位のデフォルト設定
「メッセージ受信待機時間」= 0〜20秒をキュー全体に設定可能

#### API呼び出し単位の設定
`ReceiveMessage` 呼び出しのパラメータで `WaitTimeSeconds` を指定可能

### 動作例

#### WaitTimeSeconds = 0（ショートポーリング）
```
Consumer が ReceiveMessage すると「メッセージなし」と即返ってくる
→ 短時間で大量にリクエストしてしまう（コスト高）
```

#### WaitTimeSeconds = 20（ロングポーリング）
```
Consumer が ReceiveMessage すると、メッセージが到着するまで最大20秒待つ
→ メッセージが来ればすぐ返す
→ 来なければ20秒後に空レスポンス
```

## ポーリングの仕組み

### ショートポーリング（Short Polling）
- `WaitTimeSeconds = 0`
- Consumer が「新しいメッセージある？」と聞いたら、すぐ答える
- もし無ければ即レスポンス → 無駄に API コールが増える

### ロングポーリング（Long Polling）
- `WaitTimeSeconds = 1〜20秒`
- Consumer が問い合わせたときに、メッセージが無ければ最大20秒間待機
- その間に新しいメッセージが届いたら即返す
- 無ければ「無し」で返す
- 無駄なリクエストを減らせるのでコスト最適

### ポーリングする主体（Consumer側）

**重要**: SQS は自分からメッセージを送ってはこない（Push型じゃない）

- EC2 や ECS 上の Worker、または Lambda が「取りに行く（Pull型）」のが基本
- **例外**: SQS を Lambda トリガーにすると、AWS 側が裏でポーリングしてくれる

### まとめ
- **メッセージ受信待機時間** = ポーリング時にどれくらい待つかの設定
- SQS は Push じゃなくて Pull 型（Consumer が取りに行く）
- Long Polling にすると効率的・低コストになる

## EC2/ECS での Consumer 実装

### 基本的な処理フロー
EC2 や ECS 上で動く Consumer アプリケーションは、基本的に SQS に対してポーリングし続ける仕組み
（SQS は Push 型じゃなくて Pull 型だから、Consumer から「取りに行く」必要がある）

```
Consumer（EC2など）
↓
ReceiveMessage を SQS に投げる
↓
メッセージがあれば返ってくる
↓
処理 → DeleteMessage
↓
また ReceiveMessage して次を取りに行く
→ この繰り返し
```

### ポーリング設定の優先順位

ポーリングは「自前処理」と「SQS の設定」の両方が関係する

#### 1. EC2/ECS 側（自前処理）
- `ReceiveMessage` を呼ぶコードを書く必要がある
- そのときに `WaitTimeSeconds` を API のパラメータで指定できる

#### 2. SQS キュー側（管理コンソールや設定）
- 「メッセージ受信待機時間（デフォルト）」を設定できる
- これは API 呼び出しで `WaitTimeSeconds` を指定しなかった場合に使われる値

### 設定の優先順位

**API 呼び出し時に指定した `WaitTimeSeconds` が優先される**

- キューに設定した値は「デフォルト値」として機能する
- 「ダブる」わけじゃなくて、EC2 で明示的に指定すればそれが使われるし、指定しなければ「SQS キューの設定値」が使われる

#### 設定例

##### コードで指定しない場合
```python
sqs.receive_message(QueueUrl=queue_url)
```
→ キューに設定された待機時間（例: 10秒）が適用される

##### コードで指定する場合
```python
sqs.receive_message(QueueUrl=queue_url, WaitTimeSeconds=20)
```
→ API パラメータの20秒が適用される（キュー設定は無視される）

### 実運用のベストプラクティス

- **EC2/ECS でワーカーを書くなら、コードで `WaitTimeSeconds` を明示的に指定するのが普通**
- **キューの設定値は「デフォルト（保険）」くらいに考えておけば OK**

## Visibility Timeout vs WaitTimeSeconds の違い

### Visibility Timeout（可視性タイムアウト）

#### 対象
**すでに取得されたメッセージ**

#### 意味
Consumer が受け取ったメッセージを、一定時間他の Consumer に見えなくする時間

#### 目的
- **重複処理を防ぐ**
- Consumer が処理中に「別の Consumer が同じメッセージを取ってしまう」のを回避する

#### 処理の流れ
1. Consumer が `ReceiveMessage` でメッセージ取得
2. そのメッセージは Visibility Timeout の間は他の Consumer から見えない
3. Consumer が `DeleteMessage` すれば削除される
4. もし削除しなければ Timeout 終了後に再び可視化され、別の Consumer が取れる

### WaitTimeSeconds（メッセージ受信待機時間）

#### 対象
**まだ取得されていないメッセージ**

#### 意味
Consumer が SQS に「メッセージある？」と問い合わせるとき、無ければ最大どれだけ待つか

#### 目的
- **無駄なポーリングを減らしてコスト削減**
- **新しいメッセージが来たらすぐに受け取れるようにする**

#### 処理の流れ
1. Consumer が `ReceiveMessage` 呼び出し
2. メッセージがあれば即返す
3. 無ければ `WaitTimeSeconds` の間は待つ
4. その間にメッセージが来たら即返す
5. 来なければ待ち時間後に空レスポンス

### 違いを一言でいうと

| 設定 | 意味 |
|------|------|
| **Visibility Timeout** | 「取った後に、他の人に見せない時間」 |
| **WaitTimeSeconds** | 「取りに行ったとき、無ければ待つ時間」 |

### 設定例

#### WaitTimeSeconds = 20秒
Consumer が SQS に問い合わせると、最大20秒間待ってからメッセージを返す

#### Visibility Timeout = 30秒
Consumer がメッセージを受け取ったら、その30秒間は他の Consumer には見えない

SQSキューに溜まったメッセージ数をトリガーにして、EC2のAuto Scalingを制御する仕組み のことです。

背景

Webアプリなどで「リクエストを一旦 SQS に貯めて、EC2ワーカーで処理する」構成がよくある

キューが空ならEC2台数を減らす、キューに大量に溜まったらEC2を増やす、としたい

これを自動化するのが「ターゲット追跡スケーリングポリシー + ApproximateNumberOfMessages」

ApproximateNumberOfMessages とは

SQSのメトリクスで、キュー内に「まだ処理されていないメッセージ数」を表す

例:

ApproximateNumberOfMessages = 100 → 未処理メッセージが100件ある

ターゲット追跡スケーリングポリシー

Auto Scaling のスケーリングポリシーの一種

「このメトリクスをこの値に保つように台数を調整する」という方式

例:

ターゲット値を 10 に設定

意味：「EC2インスタンス1台あたり平均して10メッセージくらいで回せるように、インスタンス数を調整する」

動作イメージ

SQS にメッセージが急に溜まる（例: 1000件）

ApproximateNumberOfMessages の値がターゲット値を大きく超える

Auto Scaling グループが EC2 を増やす（スケールアウト）

EC2 が処理を進める → キューが減る

メッセージ数がターゲット値を下回る → スケールイン

メリット

手動で「CPUが80%になったら増やす」とか考えなくて良い

キューの長さに応じて自動で台数調整できる

バックエンドのワーカー処理に最適

まとめ

 ApproximateNumberOfMessages = SQSの未処理メッセージ数
 ターゲット追跡ポリシー = その数を目標値に近づけるようにEC2台数を増減させる仕組み
 「SQSに溜まったメッセージ数を見て自動スケーリングする」 → バックエンド処理の効率化