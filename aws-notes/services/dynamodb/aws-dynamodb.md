# DynamoDB 一枚ノート（概要サマリー）

## 基本
- 定義: AWS のマネージド型 NoSQL（キー・バリュー/ドキュメント）。
- 主な用途: セッション/プロフィール、ショッピングカート、イベントログ、IoT、ゲームランキングなど。
- 特徴: サーバーレス/自動スケール、高スループット・低レイテンシ、強い耐障害性。
DynamoDBテーブルはデフォルトでマルチAZにテーブルを構成

## クラス/タイプ
- Standard: 頻繁アクセス向けの標準クラス。まずは既定に。
- Standard-IA: 低頻度アクセス向け。ストレージ単価は安いがアクセス単価が高め。アクセス多いと割高。

## 主なオプション・追加機能
1) キャパシティモード
1 オンデマンド (On-Demand Capacity Mode)
- 予約不要（事前設定なし）
- リクエストが来た分だけ自動で処理能力をスケール
- 課金は「実際に処理したリクエスト数」に基づく（従量課金）
- トラフィックが予測できない場合や、新規サービス向け
On-Demand モードでは Auto Scaling は不要＆使えない

2. プロビジョンド (Provisioned Capacity Mode)
- キャパシティを事前に割り当てる（RCU / WCU を指定）
- 課金は「設定したキャパシティ」に基づく（使わなくても支払いが発生）
- Auto Scaling Policy（ASポリシー） を設定すれば、アクセス量に応じて自動調整できる
- プロビジョンドはさらに ASポリシーで自動スケーリングを設定可能
- コスト/注意: スパイクに強いのはオンデマンド。長期安定はプロビジョンドが安い傾向。

2. リザーブドキャパシティ (Reserved Capacity)
- プロビジョンドモード専用の割引制度
- 1年 or 3年の契約をする代わりに、プロビジョンドの料金が割引になる
- EC2 のリザーブドインスタンス（RI）に近い考え方
- 前払いあり／なしのプランを選べる
つまり「リザーブドキャパシティ」は キャパシティモードそのものではなく、プロビジョンドモードの割引オプション。

2) ストレージクラス
- 使いどころ: Standard（通常用途）/ Standard-IA（過去ログ等の低頻度）。
- コスト/注意: IA はストレージ安いが読み書き高い。多アクセスだと逆効果。

3) インデックス（LSI/GSI）
-インデックスとは？

DynamoDBは基本「パーティションキー（＋ソートキー）」でしか検索できない

でも実際のアプリでは「別の属性で検索したい！」ってケースが多い

👉 そこで「インデックス」を作って別の検索パターンを実現できる

GSI（Global Secondary Index）とは？

テーブルのパーティションキー・ソートキーとは異なる属性 を使って検索できるインデックス

「Global」というのは、元のテーブルのパーティションキーと無関係に検索できる、という意味

例：

元テーブル：UserID（PK）, OrderID（SK）

GSI：Email をキーにするインデックスを作る
→ 「メールアドレスからユーザーを検索」できるようになる

4) Streams（変更イベント）
- 使いどころ: Lambda/Kinesis でイベント駆動、監査、非同期処理。
- 設定/上限: 保持 24 時間、NEW/OLD 画像の選択。
DynamoDB Streams

テーブルに対する「項目の変更ログ」

→ EventBridgeには直接送れない（Lambda/Kinesisが必要）

DynamoDB イベント通知（EventBridge連携）

最近追加された機能で、テーブル更新イベントを 直接 EventBridge に発行できる

（ただし Streamsと比べると、保持・詳細情報は限定的）

DynamoDB Streams は 変更ログを保持するだけの仕組み

「誰かに通知する」機能は持っていない

代わりに Streamsをトリガーにして起動できるのは Lambda or Kinesis

5) TTL（Time to Live）
- 使いどころ: セッション/キャッシュの自動削除。
- 注意: 削除はベストエフォートで遅延あり。

6) バックアップと復元
- 使いどころ: オンデマンドバックアップ、PITR（~35日）で誤操作/DR 対応。

7) 暗号化
- 既定で有効。KMS（管理キー/顧客管理キー）を選択可能。

8) グローバルテーブル
- 使いどころ: マルチリージョン配信/DR。アクティブ-アクティブ複製。
- 注意: 競合解決/整合モデルの理解が必要。

9) DAX（DynamoDB Accelerator）
DAXとは？

DynamoDBにフルマネージドでくっつけられるキャッシュ層

読み取り処理をミリ秒ではなく マイクロ秒レベル に高速化できる

RedisやMemcachedのように自分でキャッシュを構築する代わりに、DAXをそのまま使える

👉 Amazon DAX = DynamoDB専用のインメモリキャッシュサービス

読み取り性能を数百万リクエスト/秒レベルで処理できる

「DynamoDBで読み取りをさらに高速化したい」→ DAX

「DynamoDBのキャッシュをアプリ側で自前構築する代わりに？」→ DAXを使う

レイテンシはマイクロ秒単位に短縮

「読み取りが圧倒的に多い」ワークロードで威力を発揮する
- 使いどころ: 読み取りレイテンシをマイクロ秒級へ。読み取り多いワークロード。
- 注意: SDK/一貫性の前提を確認。

書き込みではなく読み取りがきもですな

10) トランザクション

通常のDynamoDBは「1つのPutItemやUpdateItemごとに一貫性が保証」されます。

でもアプリによっては「複数アイテムをまとめて一括で成功させたい（全部成功 or 全部失敗）」という要求があります。

👉 これを実現するのが DynamoDB Transactions
- 使いどころ: 複数アイテムの整合更新。最大 25 件/4MB。
- 注意: コスト/レイテンシ増。必要最小限に。
ACID特性 を持つ

Atomic（一括で成功 or 失敗）

Consistent（一貫性保持）

Isolated（分離性あり）

Durable（永続性あり）

複数アイテムをまとめて操作できる

最大 25 アイテム / 合計 4MB まで

1つのトランザクション内で Put, Update, Delete, ConditionCheck が可能

API

TransactWriteItems（書き込み系をまとめる）

TransactGetItems（読み取り系をまとめる）

一貫性

強い整合性を保証（トランザクションが完了したら全体が確定する）

コストが高め（通常の2倍くらいのリソース消費と課金）

レイテンシが増える（単純なPutItem/UpdateItemより遅い）

上限：25件/4MBまで

「DynamoDBで複数アイテムをACID特性で更新したい → TransactWriteItems」

「最大件数は？」 → 25件 / 4MB

DynamoDBトランザクション = 複数アイテムの操作を「全部成功 or 全部失敗」でまとめる仕組み
## 課金体系
- リクエスト/キャパシティ: オンデマンド（アクセス課金）/ プロビジョンド（RCU/WCU 指定 + AS）。
- ストレージ: Standard / Standard-IA。
- 付随機能: Streams 読取、バックアップ/PITR、DAX クラスター、グローバルテーブルの複製/転送、KMS API などに課金。

## よく組み合わせる AWS サービス
- AWS Lambda: Streams でイベント駆動処理。
- Amazon Kinesis: データ取り込み/ストリーム連携。
- Amazon S3: バックアップ/エクスポートや ETL の中継。
- Amazon API Gateway/AppSync: サーバーレス API バックエンド。
- Amazon CloudWatch: メトリクス/ログ監視、アラーム。

## メモ（任意）
- 設計の勘所: アクセスパターン駆動設計、ホットパーティション回避、単一テーブル設計の段階導入、強/最終的整合の使い分け。
- よくある落とし穴: Scan 多用でコスト/レイテンシ増、1MB 応答上限とページング未実装、キー偏りによるスロットリング。
