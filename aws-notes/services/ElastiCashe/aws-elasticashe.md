# Amazon ElastiCache

## ElastiCacheの役割

### セッション管理
ログイン状態や一時的なユーザーデータをRedisに保存 → どのEC2に振られても参照可能

### DBキャッシュ
ニュース記事やランキングなど、繰り返し参照されるデータをキャッシュしてDB負荷を軽減

### 高速応答
キャッシュヒットすればDBに行かずに数ミリ秒で応答可能

## ElastiCache for Redis

### 特徴
- **データ構造を持つ**（String, Hash, List, Set, Sorted Set など豊富）
- **永続化（スナップショット）やレプリケーションが可能**
- **Pub/Sub もサポート**（通知・ランキング処理などに便利）
- **高可用性（Multi-AZ）構成が組める**

### 向いているケース
- **セッション管理**（ユーザーログイン情報など）
- **ランキング/スコア集計**（ニュース記事の人気順など）
- **キャッシュ＋永続性をある程度求める**
- **将来の機能拡張**（検索・通知・キュー用途）を考えている

## ElastiCache for Memcached

### 特徴
- **シンプルで軽量**（Key-Value のみ）
- **水平方向にスケールしやすい**（ノード追加でキャッシュ容量増加可能）
- **永続化なし**（完全に揮発性キャッシュ）
- **マルチスレッド対応**でスループット高め

### 向いているケース
- **単純なキャッシュのみが目的**
- **一時的データの保存**（失っても影響が少ない）
- **構成をシンプルに保ちたい場合**

### 最適な用途
- **「読み取り処理の効率化」ならMemcachedが最適**
- **「DBへの読み取り負荷を軽減するキャッシュ専用用途」ではMemcachedが無駄なく速い**

## Redis vs Memcached 比較

### Redis
- **セッション管理、ランキング、Pub/Sub、永続化など多機能**
- **少しオーバーヘッドがある**（多機能ゆえ）
- **高度な機能を使わないなら「オーバースペック」になり得る**

### Memcached
- **シンプルに「キャッシュ」用途ならベスト**
- **読み取り負荷分散をシンプルにやりたいときに最適**

## 選択指針

### ニュースサイトでの読み取り効率化
**「読み取りトラフィックを効率的にさばく」目的なら**
> **ElastiCache Memcached を選ぶのが最適**

### 将来の機能拡張を想定
**「セッション管理」「ランキング」「複雑なデータ構造利用」など将来の機能拡張を想定するなら**
> **Redis を選ぶ方が拡張性が高い**

## 使い分けまとめ

| 用途 | 推奨エンジン |
|------|-------------|
| **キャッシュ専用 & 読み取り効率化重視** | Memcached |
| **セッション管理や動的機能も視野** | Redis |

## Redis Pub/Sub機能

### 仕組み
- **Publisher（送信者）** が特定のチャンネルにメッセージを送る
- **Subscriber（受信者）** はそのチャンネルを購読してリアルタイムに受け取る

**Redis はこのPub/Subを組み込みでサポートしているので、メッセージブローカー的な使い方が可能**

### 実装例

#### シンプルな流れ
1. **サーバーA（Publisher）** が `PUBLISH news "New article released!"` を実行
2. **サーバーB（Subscriber）** が `SUBSCRIBE news` していると、即座に `"New article released!"` を受け取る

### ユースケース
- **チャットアプリのリアルタイムメッセージ配信**
- **通知システム**（新しいイベントが発生したときに複数クライアントに配信）
- **ゲームサーバーでのリアルタイムイベント共有**

### 注意点
- **RedisのPub/Subは永続化されない**（一瞬で流れていく）
- **過去に送られたメッセージを後から購読して受け取ることはできない**
- **「ちゃんと全員に届けたい」「履歴を残したい」場合はRedis StreamsやSQS/SNSを使うのが推奨**

### Memcachedとの比較
- **Memcached**: Pub/Sub機能はない
- **シンプルな「分散キャッシュ」専用**
- **データ構造はキー・バリューのみ**
- **永続化や高度な機能も持たない**

## ElastiCacheスケーリング方法

### 1. スケールアウト（ノードを増やす）

#### Redis
- **シャーディング（クラスターモード有効）**でデータを分散
- **読み取り専用レプリカを追加**して読み込み負荷を分散

#### Memcached
- **ノードを追加すれば自動的にキーを分散して使える**（シンプル）

> ** 一番よく使われる方法**

### 2. スケールアップ（ノードのスペックを上げる）
- **インスタンスタイプを変更してCPU/メモリ性能を強化**
- **データ量やアクセス数が増えたときに有効**

### 3. シャーディング（データ分割）

#### Redis
- **「クラスターモード有効」にすると、複数ノードにデータをキー範囲ごとに分散配置**
- **超大規模データを扱うときに必須**

#### Memcached
- **元からシンプルなシャーディング構造**（クライアント側で分散処理）

### 4. 読み取りレプリカ（Redis限定）
- **Redisではプライマリ＋リードレプリカ構成が可能**
- **読み込みトラフィックを複数レプリカに分散できる**
- **フェイルオーバーの冗長化にも役立つ**

## ElastiCacheの制約事項

### Memcachedクラスターの制約
**保存されたデータを永続的に保持することやデータパーティショニングを実現することができない**

### Redis OSSクラスターの制約
**クラスターモードが無効化されたAmazon ElastiCache Redis OSSクラスターでは、データパーティショニングが利用できない**

## Redisクラスターモード比較

### クラスターモード無効（Cluster Mode Disabled）

#### 構成
**1つのプライマリ + 任意のリードレプリカ**

#### 特徴
- **すべてのデータが1つのプライマリノードに入る**
- **レプリカは読み取り専用**（スケールアウトは読み込み負荷分散のみ）
- **フェイルオーバーは可能**

#### 制約
**1ノードのメモリサイズが上限**（数百GB程度）

> ** シンプル構成、少中規模のシステムに向く**

### クラスターモード有効（Cluster Mode Enabled）

#### 構成
- **データを複数シャード（パーティション）に分散**
- **各シャードが「プライマリ + レプリカ」を持てる**

#### 特徴
- **データを自動的に分散配置**（シャーディング）
- **最大数百テラバイト級まで拡張可能**
- **高スループット・大規模アプリに対応可能**

#### 制約
**シャード数が固定なので、後から増やす際はリシャーディング（再分散）が発生**

> ** 大規模システムや低レイテンシで大容量を扱いたいケースに向く**

## データパーティショニング

### 概要
**大きなデータセットを小さな塊（パーティション）に分割して、複数のノードやサーバーに分散して保存・処理する仕組み**

### Redis/ElastiCacheでの実装

**ElastiCache for Redisのクラスターモード有効でやっているのがまさにこれ👇**

#### 分散方法
1. **データ（キー）をハッシュ関数で計算**
2. **その結果に基づいて、特定のシャード（ノードグループ）に割り当て**

#### 分散例
```
user:1001 → シャード1
user:2005 → シャード2
user:3050 → シャード3
```

> ** こうすることで、1つのノードに負荷やデータが集中せず、全体をスケール**

### メリット
- **スケーラビリティ**: 容量も処理能力もノード数を増やせば拡張できる
- **パフォーマンス**: リクエストを複数ノードに分散できるので速い
- **耐障害性**: あるシャードが落ちても他のシャードは生きている

### デメリット/注意点
- **データが分散されるので、「全データにまたがる集計」は難しい**（分散処理が必要）
- **シャード数を後から変更するとリシャーディング（データ再配置）が必要**
- **「特定のキーは必ず同じシャードにある」ように設計しないと、一貫性のない動作になる可能性がある**

### まとめ
- **クラスターモード有効** = シャーディングによる分散配置
- **クラスターモード無効** → 小〜中規模、シンプルに1ノード＋レプリカ
- **クラスターモード有効** → 大規模スケール、シャーディング必須

## シャーディング詳細

### 概要
**大きなデータを「シャード（Shard）」と呼ばれる小さな単位に分割して、複数のノードに分散配置する仕組み**

### Redisクラスターモードでのシャーディング

#### ハッシュスロット方式
- **Redisクラスターモード有効にすると、データはハッシュスロット（0〜16383の範囲）に分割**
- **各シャードはこのスロットの一部を担当**
- **キーが格納される場所はハッシュ関数で自動決定**

#### 分散例
```
user:1001 → ハッシュ計算 → シャード1
user:2005 → ハッシュ計算 → シャード2
user:3050 → ハッシュ計算 → シャード3
```

### シャーディングのメリット

#### スケーラビリティ
**ノードを追加すればデータも処理も分散できる → 大規模対応可能**

#### パフォーマンス向上
**複数ノードに処理を分散するので同時アクセスに強い**

#### 耐障害性
**あるシャードが落ちても他のシャードは生きている**

### デメリット/注意点

- **複数シャードにまたがる集計処理は難しい**
- **シャード数を増減するとリシャーディング（再分散）が発生してコスト大**
- **設計次第でホットスポット（特定シャードにアクセス集中）が起きることもある**

### まとめ
**シャーディング = データを分割して複数ノードに分散させる技術**

> ** Redisクラスターモードでは、この仕組みで大規模スケールを実現**

---

## 永続化の違い

### Redis
インメモリDBだが、ディスクに永続化する機能を持つ

#### 代表的な方式は2つ

##### RDB スナップショット方式
- 一定間隔でメモリ全体をスナップショットとしてディスクに保存
- 再起動時はそのスナップショットから復元

##### AOF (Append Only File) 方式
- 各書き込み操作をログに追記
- 再起動時にログをリプレイして復元

**RDB + AOF の併用も可能**

**「アプリ再起動後もデータを残す」要件がある場合は Redis 一択**

### Memcached
- **永続化機能なし**
- 完全に揮発性のインメモリキャッシュ
- 再起動すれば中身は全部消える

**「一時的なキャッシュだけで十分」「再起動時に消えてもOK」なら Memcached でいい**

### まとめ
- **再起動してもデータ保持が必要** → Redis
- **シンプルで速いキャッシュだけ欲しい** → Memcached