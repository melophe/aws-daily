# Amazon RDS

## ストレージ Auto Scaling

RDSのストレージに対するAuto Scalingが利用可能。これにより、増加するデータベースのワークロードに応じてストレージ容量がダウンタイムなしで自動的にスケールされる。

**重要**: これはストレージ容量のスケーリングであるため、パフォーマンスを改善しない

## シャーディング

### 定義
大きなデータベースを複数に分割して分散させる仕組み

### 仕組み
- 各分割（シャード）は異なるサーバー（DBインスタンス）に配置される
- アプリ側は「どのシャードにデータを保存/検索するか」をキーに基づいて決める

つまり「水平分割（Horizontal Partitioning）」の一種

### シャーディングの例（ユーザーID基準）

| ユーザーID範囲 | 配置先 |
|--------------|-------|
| 1〜10000 | RDS① |
| 10001〜20000 | RDS② |
| 20001〜30000 | RDS③ |

**メリット**: 1つのDBにユーザー全員分を置かずに済み、処理を分散可能

---

## RDSにおけるスケーリングの種類

### 1. 垂直スケーリング（Vertical Scaling）

#### 概要
DBインスタンスのインスタンスタイプを変更して性能を上げ下げする

#### 例
`db.t3.medium` → `db.r6g.large`

#### 注意
基本的に手動。自動では切り替わらない

### 2. ストレージの自動スケーリング（Auto Storage Scaling）

#### 概要
RDSではストレージ容量を自動で拡張可能

#### 対応エンジン
Aurora / MySQL / PostgreSQLで設定可能

#### 動作
上限値を決めておけば、必要に応じて自動で容量が増加

### 3. Aurora専用のスケーリング機能

#### Aurora Auto Scaling（リーダーレプリカの自動増減）
- **動作**: 読み取りトラフィックに応じてAurora Replicasを自動調整

#### Aurora Serverless v2
- **特徴**: キャパシティを秒単位で自動スケール
- **感覚**: ほぼ「EC2のAuto Scaling」みたいな感覚で使える

## スケーリング機能の制限事項

### 通常のRDS（MySQL, PostgreSQL, Oracle, SQL Server）

#### 利用不可
「自動でインスタンスサイズを変えるオートスケーリング」はない

#### 利用可能
ストレージの自動スケーリングはある

### 読み取り負荷分散
「読み取り負荷分散でスケーリングしたい」ときはリードレプリカを追加（手動 or Aurora Auto Scaling）

---

## Amazon RDS Proxy

### 概要
RDSやAuroraの前に置くマネージド型の接続プーリングサービス

### 役割

**LambdaやFargateのように同時接続が増減するアプリからRDSにアクセスするとき：**

- 直接DBに接続すると「同時接続数の上限超過」や「接続確立のオーバーヘッド」でパフォーマンスが落ちる

**RDS Proxyを挟むと：**

- 既存の接続をプール＆再利用
- 大量の接続を効率的にさばく
- フェイルオーバー時の接続断を短縮

つまり：「DBを守るバッファ」と「接続の効率化」をしてくれる

### 主な特徴

#### 接続プールの管理
Lambdaが一気に100並列で動いても、Proxyは既存のコネクションを再利用してDBへの負荷を抑える

#### フェイルオーバー高速化
AuroraやMulti-AZ RDSのフェイルオーバー時、直接接続よりも早く再接続可能

#### セキュリティ統合
- IAM認証を使える（DBのユーザー名・パスワードをアプリ側で持たなくてよい）
- Secrets Managerと連携して自動で認証情報を更新

#### 高可用性
Proxy自体もマルチAZで冗長化されている

### 利用シーン

#### Lambda + RDS
サーバーレスで一気にスケールする処理をDBに安全に流す

#### Fargate + RDS
コンテナアプリが同時接続を急増させてもDBが落ちないようにする

#### マイクロサービス構成
複数のサービスから同じDBにアクセスしていて接続が多い場合

**RDS Proxy** = RDSやAuroraに対する接続を効率化・安定化するためのマネージド接続プーラー

### 提供機能
- コネクション管理
- フェイルオーバー短縮
- 認証情報のセキュリティ強化

### 接続プーリングの仕組み

#### 通常のDB接続（RDS Proxyなし）

- Lambda関数が1回実行されるたびに新しいDBコネクションを開く
- 接続確立にはコスト（数百ms〜秒）がかかる
- Lambdaがスケールアウトして100同時実行 → 100個の接続が一気にRDSに到達

**結果：**
- RDSの同時接続数制限に引っかかる
- 接続確立のオーバーヘッドでパフォーマンス低下

#### RDS Proxyあり（接続プーリング）

- LambdaからのリクエストはまずRDS Proxyに届く
- RDS Proxyが「すでに開いてあるDBコネクションを再利用」してDBに渡す

**つまり：**
- Lambda 100実行でも、DBには20〜30コネクション程度しか作られない
- 新しい接続を毎回確立せずに「既存のコネクション」を使うので高速

### 「プールして再利用」のイメージ

**プール** = あらかじめ作ってある接続のストック

```
Lambda → 「DBつないで！」
Proxy  → 「もう開いてある接続を貸すね」
Lambda → 「処理終わった」
Proxy  → 「じゃあその接続はまたプールに戻す」
```

**ポイント**: コネクションプールの貸し借りで、DBの負荷を減らしつつスピードも上がる

### アーキテクチャ図比較

#### RDS Proxyなし
```
Lambda(1) ─┐        ┌─> New Conn ──> RDS
Lambda(2) ─┼─> New Conn ──> RDS
Lambda(3) ─┘        └─> New Conn ──> RDS
```

#### RDS Proxyあり
```
Lambda(1) ─┐
Lambda(2) ─┼─> Proxy ──> [既存コネクション] ──> RDS
Lambda(3) ─┘
```

毎回DBに新しい接続を作るのではなく、Proxyがあらかじめ開いてある接続を貸し借りする仕組み

### メリットまとめ

- 接続確立のオーバーヘッドを削減
- 同時接続数を抑制
- Lambdaのスパイクにも耐えられる

---

## IAMデータベース認証

RDSのユーザー認証をIAMを使って行う仕組み

通常は「DBユーザー名 + パスワード」でログインするが、IAM認証を有効化するとパスワードの代わりに一時的な認証トークンでログイン可能になる。

一言でいうと：「RDSのログインをIAMロールに任せる仕組み」

### 特徴

#### 一時認証トークン
- 有効期限は15分間
- 使い捨てなのでパスワード管理が不要

#### IAMロールと統合
- EC2 / Lambda / ECSなどにアタッチしたIAMロールから認証可能
- Auto Scaling環境でもセキュアに動作
- Secrets Manager不要（ただし組み合わせも可能）

「パスワードを永続管理しない」ため、セキュリティリスクを減らせる

### 利用可能なDBエンジン

- Amazon Aurora (MySQL, PostgreSQL)
- Amazon RDS for MySQL
- Amazon RDS for MariaDB

### イメージ

1. アプリケーションはrds-db:connect権限を持つIAMロールを利用
2. aws rds generate-db-auth-tokenコマンドやSDKを使って一時認証トークンを取得
3. そのトークンを「パスワード」としてRDSにログイン

### メリット

- パスワードをコードや設定ファイルに書かなくてよい
- トークンは短命なので漏洩リスクが低い
- IAMで細かく「誰がどのDBに入れるか」を制御可能

---

## RDSモニタリング機能

### 1. Amazon CloudWatch 基本モニタリング

#### 粒度
5分間隔（有料オプションで1分間隔も可能）

#### 見えるもの
- CPU使用率
- DB接続数
- ストレージ使用量
- 読み取り/書き込みIOPS

#### 特徴
- 無料で標準提供
- ざっくりとしたリソース利用状況を見るのに便利

#### 弱点
- メモリやプロセス単位の情報は取得できない

### 2. 拡張モニタリング (Enhanced Monitoring)

#### 粒度
1秒〜1分間隔

#### 見えるもの
- CPU使用率（コア単位）
- メモリ利用状況（空き、キャッシュ、スワップ）
- ディスクI/Oの詳細（レイテンシ・スループット）
- プロセス単位のリソース使用状況

#### 特徴
- OSレベルの情報を取得可能（EC2のtopやiostat相当）
- データはCloudWatch Logsに送信される

#### 弱点
- CloudWatch Logsの利用料がかかる

#### 使いどころ
「CPUやメモリをどのプロセス・スレッドが使っているか？」を知りたいとき

### 3. Performance Insights

#### 粒度
秒〜分レベル

#### 見えるもの
- DB負荷（AAS: Average Active Sessions）
- 上位SQLステートメント
- 待機イベント（ロック待ち、I/O待ち等）

#### 特徴
- SQLレベルで「どのクエリが原因か」分析可能
- 7日分の履歴は無料、最大24か月まで保存可能（有料）

#### 弱点
- OSレベルのCPU/メモリ使用状況までは分からない

#### 使いどころ
「どのSQLがリソースを食っているか？」を知りたいとき

---

## モニタリング機能の比較

| 機能 | レイヤー | 主な用途 |
|------|----------|----------|
| **CloudWatch基本** | AWS メトリクス | ざっくり把握 |
| **Enhanced Monitoring** | OSレベル (リソース) | CPU、メモリ、I/Oの利用状況を把握 |
| **Performance Insights** | DBレベル (SQL) | どのSQLがボトルネックかを特定 |

### まとめ

| 用途 | 推奨機能 |
|------|----------|
| ざっくり把握 | CloudWatch 基本モニタリング |
| CPUやメモリをどのプロセス/スレッドが使ってる？ | 拡張モニタリング |
| どのSQLが原因？ | Performance Insights |

---

## RDSとサブネットの基本

### RDSはマネージドサービス

- OSパッチ適用やバックアップ、モニタリングはAWSが裏で処理
- EC2のようにyum/aptで自分がパッケージを入れる必要はない
- 通常はプライベートサブネットに配置
- セキュリティ上、外部（インターネット）に直接出さないのがベストプラクティス

### NAT Gatewayは必要か？

- RDS自体はNAT Gatewayを必要としない
- RDSはユーザーがOSにログインしてパッケージを入れるような使い方はできない
- AWSが裏でパッチやメンテナンスをやるときは、AWS内部の管理ネットワークを経由して行う
- したがって「yum updateのためにNATが必要」ということはない

#### ただし注意点

RDSから外部サービス（例：外部API、サードパーティライセンスサーバ、KMSを別リージョンで使う等）にアクセスしたいケースはありえる。その場合はNAT GatewayやVPCエンドポイントが必要。

1. RDS 自動バックアップ

自動バックアップの保持期間は 最大35日 まで設定可能

→ 保持30日 の要件は自動バックアップだけで満たせる

ただしこれは「自動バックアップのみ」

2. 手動スナップショット

デフォルトでは削除しない限り 無期限に保存される

→ 30日で自動削除はされないので、管理が必要

3. 最適な解決方法

AWS Backup を利用する

RDSの自動バックアップ＋手動スナップショット両方を対象にできる

バックアッププランで保持期間を30日に設定すれば、自動削除される

マルチAZ冗長化も継続利用でき、かつコストを抑えられる

RDS 自動バックアップ (Service Native)

RDS自体の機能

保持期間は 1～35日 の範囲で設定可能

自動バックアップは「RDSの機能」であり、AWS Backupの対象外

AWS Backup の対象になるバックアップ

RDSの手動スナップショット

AWS Backupから「オンデマンド」または「バックアッププラン」でスナップショットを取得できる

その際に 保持期間 (Retention) を 30日に設定すれば、自動削除可能

つまりどういうことか

自動バックアップ → RDSの設定で30日にする

手動スナップショット → AWS Backupで保持期間を30日にする