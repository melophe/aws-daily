# Amazon RDS

## ストレージ Auto Scaling

RDSのストレージに対するAuto Scalingが利用可能。これにより、増加するデータベースのワークロードに応じて**ストレージ容量がダウンタイムなしで自動的にスケール**される。

> **重要**: これはストレージ容量のスケーリングであるため、パフォーマンスを改善しない

## シャーディング

### 定義
**大きなデータベースを複数に分割して分散させる仕組み**

### 仕組み
- 各分割（シャード）は**異なるサーバー（DBインスタンス）**に配置される
- アプリ側は「どのシャードにデータを保存/検索するか」を**キーに基づいて決める**

> つまり「**水平分割（Horizontal Partitioning）**」の一種

### シャーディングの例（ユーザーID基準）

| ユーザーID範囲 | 配置先 |
|--------------|-------|
| 1〜10000 | RDS① |
| 10001〜20000 | RDS② |
| 20001〜30000 | RDS③ |

**メリット**: 1つのDBにユーザー全員分を置かずに済み、処理を分散できる


## RDSにおけるスケーリングの種類

### 1. 垂直スケーリング（Vertical Scaling）

#### 概要
DBインスタンスのインスタンスタイプを変更して性能を上げ下げする

#### 例
`db.t3.medium` → `db.r6g.large`

#### 注意
**基本的に手動。自動では切り替わらない**

### 2. ストレージの自動スケーリング（Auto Storage Scaling）✅

#### 概要
RDS ではストレージ容量を自動で拡張できる

#### 対応エンジン
Aurora / MySQL / PostgreSQL で設定可能

#### 動作
上限値を決めておけば、必要に応じて自動で容量が増加

### 3. Aurora専用のスケーリング機能

#### Aurora Auto Scaling（リーダーレプリカの自動増減）
- **動作**: 読み取りトラフィックに応じて Aurora Replicas を自動調整

#### Aurora Serverless v2
- **特徴**: キャパシティを秒単位で自動スケール
- **感覚**: ほぼ「EC2のAuto Scaling」みたいな感覚で使える

## スケーリング機能の制限事項

### 通常のRDS（MySQL, PostgreSQL, Oracle, SQL Server）

#### ❌ 利用不可
「自動でインスタンスサイズを変えるオートスケーリング」はない

#### ✅ 利用可能
ストレージの自動スケーリングはある

### 読み取り負荷分散
「読み取り負荷分散でスケーリングしたい」ときは**リードレプリカを追加**（手動 or Aurora Auto Scaling）

## Amazon RDS Proxy

### 概要
**RDS や Aurora の前に置くマネージド型の接続プーリングサービス**

### 役割

**Lambda や Fargate のように同時接続が増減するアプリから RDS にアクセスするとき：**

- 直接 DB に接続すると「同時接続数の上限超過」や「接続確立のオーバーヘッド」でパフォーマンスが落ちる

**RDS Proxy を挟むと：**

- 既存の接続をプール＆再利用
- 大量の接続を効率的にさばく
- フェイルオーバー時の接続断を短縮

> **つまり**：「DBを守るバッファ」と「接続の効率化」をしてくれる

### 主な特徴

#### 接続プールの管理
**Lambdaが一気に100並列で動いても、Proxyは既存のコネクションを再利用してDBへの負荷を抑える**

#### フェイルオーバー高速化
**Aurora や Multi-AZ RDS のフェイルオーバー時、直接接続よりも早く再接続できる**

#### セキュリティ統合
- **IAM認証**を使える（DBのユーザー名・パスワードをアプリ側で持たなくてよい）
- **Secrets Manager** と連携して自動で認証情報を更新

#### 高可用性
**Proxy 自体もマルチAZで冗長化されている**

### 利用シーン

#### Lambda + RDS
サーバーレスで一気にスケールする処理をDBに安全に流す

#### Fargate + RDS
コンテナアプリが同時接続を急増させてもDBが落ちないようにする

#### マイクロサービス構成
複数のサービスから同じDBにアクセスしていて接続が多い場合

> **RDS Proxy** = RDSやAuroraに対する接続を効率化・安定化するためのマネージド接続プーラー

### 提供機能
- コネクション管理
- フェイルオーバー短縮
- 認証情報のセキュリティ強化

### 接続プーリングの仕組み

#### 🔹 通常のDB接続（RDS Proxyなし）

- **Lambda関数が1回実行されるたびに新しいDBコネクションを開く**
- **接続確立にはコスト（数百ms〜秒）がかかる**
- **Lambdaがスケールアウトして100同時実行 → 100個の接続が一気にRDSに到達**

**結果：**
- RDSの同時接続数制限に引っかかる
- 接続確立のオーバーヘッドでパフォーマンス低下

#### 🔹 RDS Proxyあり（接続プーリング）

- **LambdaからのリクエストはまずRDS Proxyに届く**
- **RDS Proxyが「すでに開いてあるDBコネクションを再利用」してDBに渡す**

**つまり：**
- Lambda 100実行でも、DBには 20〜30コネクション程度しか作られない
- 新しい接続を毎回確立せずに「既存のコネクション」を使うので高速

### 「プールして再利用」のイメージ

**プール** = あらかじめ作ってある接続のストック

```
Lambda → 「DBつないで！」
Proxy  → 「もう開いてある接続を貸すね」
Lambda → 「処理終わった」
Proxy  → 「じゃあその接続はまたプールに戻す」
```

> **ポイント**: コネクションプールの貸し借りで、DBの負荷を減らしつつスピードも上がる

### アーキテクチャ図比較

#### RDS Proxyなし
```
Lambda(1) ─┐        ┌─> New Conn ──> RDS
Lambda(2) ─┼─> New Conn ──> RDS
Lambda(3) ─┘        └─> New Conn ──> RDS
```

#### RDS Proxyあり
```
Lambda(1) ─┐
Lambda(2) ─┼─> Proxy ──> [既存コネクション] ──> RDS
Lambda(3) ─┘
```

**毎回DBに新しい接続を作るのではなく、Proxyがあらかじめ開いてある接続を貸し借りする仕組み**

### メリットまとめ

- 接続確立のオーバーヘッドを削減
- 同時接続数を抑制
- Lambdaのスパイクにも耐えられる

RDS Proxy なしのとき

Lambda 1実行 → RDSに 新しい接続（コネクション） を確立

Lambda が並列で 100 実行 → RDSに 100本の新規接続 が一気に飛ぶ

問題点：

接続確立のオーバーヘッド（毎回TCP/SSLハンドシェイク）で遅い

RDSの「同時接続数の上限」に達すると エラー（Too many connections）

スパイクに弱い（Lambdaが急にスケールしたときにDBがパンク）

🔹 RDS Proxy ありのとき

Lambda からのリクエストはまず RDS Proxy に届く

Proxyは 既に開いてある接続を再利用（プール） してRDSに渡す

Lambdaが100同時実行されても、RDSに対する接続は例えば 20〜30本程度に制御される

メリット：

DBの同時接続数を抑制

接続確立の時間を短縮（新規で開かず既存を使う）

スパイクに強い

### 接続パターンの視覚的比較

#### Proxy なしの場合
```
Lambda(1)   ──> New Connection ──> RDS
Lambda(2)   ──> New Connection ──> RDS
...
Lambda(100) ──> New Connection ──> RDS
```

#### Proxy ありの場合
```
Lambda(1) ──┐
Lambda(2) ──┼─> RDS Proxy ──> [既存コネクション] ──> RDS
Lambda(3) ──┘
```

### まとめ

**RDS Proxyなし：**
- Lambdaの実行ごとにRDSへの新しい接続が必要になる
- DBが接続数オーバーやオーバーヘッドで遅くなる

**RDS Proxy使用：**
- 接続をプールして再利用できるので効率的に動作する

RDS Proxy があると 「1つだけ」ではなく「必要な数だけ」接続を持つ

ただし 無限に増やすのではなく、効率的にまとめてプール管理するのがポイント

結果として、DB側の負荷は大幅に軽減される