
# Amazon S3

## S3クロスリージョンレプリケーション（Cross-Region Replication: CRR）

### 概要

**S3バケットのオブジェクトを別リージョンのバケットに自動的に複製する機能**

### 基本構成

- **ソースバケット**と**宛先バケット**を設定
- 新しくアップロード・更新されたオブジェクトが、自動で別リージョンにコピーされる
- **コピーは非同期処理**（リアルタイムではなく、若干の遅延あり）

### 前提条件

- ソースと宛先の**両方のバケットでバージョニングが有効**
- **適切な IAM 権限**（レプリケーション用ロール）
- **レプリケーションルール設定**（バケット全体か、特定プレフィックス/タグごとに制御可能）

## ユースケース

### 災害対策 (DR)
東京リージョンにあるデータを、大阪リージョンやシンガポールにコピーしてBCP対策

### グローバル配信
ユーザーに近いリージョンからアクセスさせて、レイテンシ削減

### コンプライアンス要件
データを必ず複数の地理的リージョンに保持する必要がある場合

## 重要な制約

- **レプリケーションは新しいオブジェクトだけが対象**
- 過去のオブジェクトは自動コピーされない（必要ならS3バッチオペレーションで対応）
- 双方向レプリケーションはできるが、ループ防止に工夫が必要
- **追加のデータ転送コストがかかる**

## 同一リージョンレプリケーション（SRR: Same-Region Replication）

### 特徴

- **同じリージョン内の別バケット**に複製
- **マルチアカウント環境やセキュリティ隔離**に使用

## S3マルチリージョンアクセスポイント

**複数リージョンのバケットを束ねて、最適なリージョンにルーティングする仕組み**

## 双方向レプリケーションの仕組み

### 基本原則

S3 CRR は**一方向（ソース → 宛先）のみサポート**

### 双方向にする方法

双方向にしたい場合は以下の2つのレプリケーション設定をそれぞれ作る必要がある：

- **バケットA → バケットB** のレプリケーションルール
- **バケットB → バケットA** のレプリケーションルール

### レプリケーションループ対策

#### 問題

双方向にすると、同じオブジェクトが **A ⇔ B で無限コピー**されるリスクがある

#### 対策

- **レプリケーション元のバケットID**（バケットの所有者）やメタデータを利用してフィルタリング
- **「レプリケーションでコピーされたオブジェクトは再レプリケーションしない」という仕組み**がS3に組み込まれている

## S3バージョニング (Versioning)

### 概要
**S3バケットに保存するオブジェクトを世代管理できる機能**

### 基本動作

#### バージョンID付与
バージョニングを有効化すると、オブジェクトに**バージョンID**が自動で付与される

#### 新バージョン作成
同じキー（例: file.txt）にアップロードすると**新しいバージョン**が作成され、古いバージョンも残る

> **特徴**: 「上書き」ではなく「履歴が全部残る」状態

### 復元機能

#### 過去バージョンの復元
誤って上書きした場合でも以前のバージョンに戻せる

#### 削除からの復元
- 削除すると「**Delete Marker**」という特別なバージョンが追加されるだけ
- そのマーカーを消せば復活

### ユースケース

- **誤操作対策**（上書きや削除からの保護）
- **監査対応**（どの時点でどんなデータがあったか追跡可能）
- **クロスリージョンレプリケーション (CRR) の前提機能**
  - レプリケーションを設定するにはバージョニングが必須

### 注意点

#### 容量増加
- 古いバージョンも残り続けるため、**ストレージコストが増える**
- **ライフサイクルルール**で古いバージョンを自動削除/Glacierに移行するのが一般的

#### 設定変更の制限
バージョニングは「有効化 or 無効化」できるが、一度有効化したら完全には解除できず「**一時停止（suspended）**」にするだけ

---

## リクエスタ支払い機能 (Requester Pays)

### 概要
通常、S3の利用料金（データ転送料やリクエスト料）は バケット所有者 が負担

しかし「Requester Pays」を有効にすると、
**バケットからデータを取得した人（リクエスタ）が料金を支払う 仕組み**

### 仕組み
1. S3バケット側で「Requester Pays」を有効化する
2. そのバケットからオブジェクトを取得（GET, LIST, HEAD など）するユーザーは
   - 自分のAWSアカウントで認証してアクセス
   - そのリクエスト料・データ転送料が 自分のアカウントに課金される

### ユースケース

#### 大規模データの公開配布
- 研究データ、衛星写真、オープンデータなどを誰でも使えるようにしたい
- でも配布コストはバケット所有者ではなく利用者に負担してほしい場合

#### 課金を明確に分けたい
- 共同研究や外部パートナーがデータにアクセスする際に、
- 「自分が使った分は自分で払う」ようにしたい場合

### 注意点
- **「Requester Pays」バケットは 匿名アクセスできない**
- 必ずAWSアカウントで認証する必要がある
- **バケット所有者はストレージ料金は負担し続ける**
  - 保管料はバケット所有者
  - 転送料・リクエスト料はリクエスタ
- 一般的なWebサイトホスティングには不向き

### まとめ
-  **リクエスタ支払い機能 = データを取得した人がリクエスト料・転送料を支払う仕組み（S3）**
-  **バケット所有者は保存コストを払い続けるが、転送コストを利用者に転嫁できる**
-  **公開データ配布や外部コラボに便利**

**「S3のデータ転送コストを利用者に負担させられる機能」**

---

## ストレージクラス分析 (S3 Storage Class Analysis)

### 概要
S3オブジェクトのアクセスパターンを分析する機能

「このデータは頻繁にアクセスされてる？ほとんどアクセスされてない？」を統計的に把握できる

結果を見て、どのストレージクラスに移行すべきか判断するためのデータを提供する

### 仕組み
1. バケットまたはプレフィックス単位で分析を有効化
2. S3がオブジェクトのアクセスパターンを収集（読み取り回数など）
3. 分析結果は CSV形式でS3に出力される
4. それをAthena, Redshift, QuickSightなどで可視化・分析できる

### ユースケース
- 「このバケットのファイルはあまりアクセスされてないから S3 Standard-IA に移そうかな？」
- 「頻繁に使うデータが実は Glacier に入っていて非効率になっていないか？」を確認したいとき
- コスト最適化の判断材料にする

### 注意点
- **Storage Class Analysis 自体は「自動移行しない」**
- あくまで「判断材料」
- **移行は ライフサイクルポリシー を別途設定する必要あり**
- データの収集・分析には時間がかかる（数日〜数週間）
- 課金は「分析レポート用のS3ストレージ料金」のみ

### まとめ
-  **ストレージクラス分析 = S3オブジェクトのアクセスパターンを分析して、どのストレージクラスに移すべきか判断するための機能**
-  **自動で移行はしない（ライフサイクルルールは別に必要）**
-  **出力データを使ってコスト最適化の戦略を立てられる**

**「S3の利用状況を分析して、IAやGlacierに移す判断材料を提供してくれるツール」**