# AWS Direct Connect

## Direct Connectとは

AWSとオンプレミス（自社データセンターなど）を専用線で直結するサービス。

通常のインターネット経由ではなく、専用回線経由でAWSと通信できる。

### 特徴

- 高速（1Gbps〜100Gbpsまで）
- 安定（遅延が少ない）
- セキュア（閉域網）

## VIF（Virtual Interface）とは

Direct Connectの物理回線の上で作る「論理的な接続口」のこと。

Direct Connectの回線1本で、複数のVIFを作ってAWSの異なるサービスやVPCに接続できる。

### VIFの種類

| 種類 | 用途 | 接続先 | 主な利用シーン |
|------|------|--------|---------------|
| Private VIF | VPC（プライベートネットワーク） | VPC内のリソース（EC2、RDSなど） | オンプレからVPC内のデータベースへ安全にアクセス |
| Public VIF | AWSのパブリックサービス | S3、DynamoDB、SNSなど | オンプレからS3などAWSサービスに直接アクセス |
| Transit VIF | Transit Gateway経由 | 複数のVPCをまとめて接続 | 複数VPCを統合的に接続したい場合 |

---

# AWS Application Migration Service (MGN)

AWS Application Migration Service (MGN) は、いわゆる「リフト＆シフト移行（Lift & Shift）」を自動化するサービス。
つまり「既存のサーバーをそのままAWS上で動かす」ことを目的としている。

## 仕組み（ざっくり流れ）

### 1. エージェントをインストール
移行したいオンプレミスのサーバー（Windows/Linux）に MGN エージェントを導入。

### 2. ブロックレベルでデータを継続レプリケーション
ディスクの変更ブロックを継続的にキャプチャして、AWS上の「レプリケーションサーバー」へ転送。
（転送はTLSで暗号化、保存はKMSで暗号化）

### 3. テストインスタンスを起動して検証
移行前に「本番と同じ構成」でテスト実行できる。
→ 移行リハーサルが安全に可能。

### 4. カットオーバー（最終切替）
最後の同期をして、AWS上のEC2インスタンスを起動。
ダウンタイムは数分〜数十分程度。

### 5. （オプション）フェイルバック
AWS→オンプレ側に逆方向の同期も可能。
トラブル時の「戻す」対策にも使える。

**まとめ：**「既存サーバーを"止めずに"AWSにそのまま持っていくための移行サービス」

---

## ユースケース

### ① オンプレミス → AWS へのサーバー移行（Lift & Shift）

**概要：**

オンプレミスで稼働中の Windows/Linux サーバー を最小限のダウンタイムで EC2 に移行するケース。

**例：**

- データセンターを閉鎖予定で、AWSに全面移行したい
- 古いハードウェアの保守コストを削減したい
- Oracle / SQL Server などを EC2 上にそのまま移したい

**特徴：**

- 継続レプリケーションで停止時間は数分程度
- アプリ再インストール不要（そのまま移行）
- OS設定・ミドルウェアも保持

---

### ② 他クラウド（Azure / GCP）→ AWS への移行

**概要：**

別クラウドで動かしているVMをAWSへリフト＆シフトする。

**例：**

- 会社方針でマルチクラウドからAWSに統合する
- 特定リージョンやコンプライアンス対応のためAWSに集約する

**特徴：**

- 既存VMにMGNエージェントを導入するだけ
- IP接続があれば転送可能（VPNでもDirect ConnectでもOK）

---

## MGN vs DMS：どっちを使うべきか

| 比較項目 | AWS MGN（Application Migration Service） | AWS DMS（Database Migration Service） |
|---------|----------------------------------------|--------------------------------------|
| 主な目的 | サーバー全体の移行（Lift & Shift） | データベースの移行 |
| 対象 | OSごと含めた「サーバー全体」（アプリ、ミドルウェア、DB含む） | DBエンジンのみ（Oracle → Auroraなど） |
| 移行内容 | OS設定、アプリケーション、ファイル、DB全部まとめて | テーブル・スキーマ・データのみ |
| 移行方法 | ブロックレベルレプリケーション（ディスクごと同期） | データレベルレプリケーション（Full Load + CDC） |
| ダウンタイム | 数分（最終カットオーバーのみ） | 数秒〜数分（継続的CDC対応） |
| 暗号化 | 転送時TLS＋保存時KMS暗号化 | 同様にTLS暗号化対応 |
| 使用例 | オンプレWindowsサーバーをそのままEC2へ | Oracle DBをAurora PostgreSQLへ変換移行 |
| フェイルバック | 対応（AWS → オンプレに戻す） | 対応していない（基本は一方向） |

---

# AWS CloudFormation StackSets

## StackSetsの登場

ここで登場するのが **AWS CloudFormation StackSets**。

StackSetsを使うと：

- 一度テンプレートを作るだけで
- 複数のアカウント／リージョンに自動展開できる
- Organizationsと連携すれば新規アカウントにも自動反映される

```
[管理アカウント]  ← StackSetを作成
   │
   ├─ OU: Production  → 東京 / シンガポール に自動デプロイ
   ├─ OU: Dev         → 東京 / バージニア に自動デプロイ
   └─ OU: Test        → 除外
```

結果として、すべての対象アカウント・リージョンに同じIAMロールや設定が一括展開される。

## StackSetsの構成要素

| 要素 | 説明 |
|------|------|
| StackSet | テンプレートの親（マスター） |
| Stack Instance | 各アカウント・リージョンに展開される個々のスタック |
| Target OU / Account | 展開先（OrganizationsのOUまたは個別アカウント） |
| Operation | 展開・更新・削除などのアクション |

## 2つの権限モード（重要）

| モード名 | 特徴 | 使う場面 |
|---------|------|---------|
| サービス管理型 (Service-managed) | AWS Organizationsと連携。OU単位で自動配布可能。 | 複数アカウント全体に展開したい時 |
| 自己管理型 (Self-managed) | 各ターゲットアカウントに手動でロール設定が必要。 | 組織を使っていない場合や個別展開時 |

## ユースケース例

| ユースケース | 具体例 |
|-------------|--------|
| 共通IAMロール配布 | 各アカウントに同じ管理者ロールを配る |
| ガードレール設定 | CloudTrail、Config、S3バケットポリシーを一括適用 |
| セキュリティ制御統一 | IAMルール・SNS通知設定を組織全体に展開 |
| マルチリージョン管理 | 各リージョンにCloudWatchアラームを自動配備 |

---

## Trusted Access（トラステッドアクセス）

AWS Organizationsの管理アカウントが、特定のAWSサービスに対して組織全体の操作を許可する仕組み。

つまり、「AWS Organizationsを信頼できるサービスとして登録し、組織全体に対してそのサービスが自動で操作できるようにする」という設定。

### なぜ必要か

通常、AWS Organizationsに所属する各メンバーアカウントには「勝手にIAMロールやリソースを作らないでね」という隔離ルールがある。

でも、たとえば下のようなケースでは、「管理アカウントが一括で操作できた方が便利」：

- StackSetsで、OU配下の全アカウントにCloudFormationを自動展開したい
- AWS ConfigやSecurity Hubを全アカウントに自動的に有効化したい
- Control Towerで新しいアカウントを作ると同時に共通設定を適用したい

このときに有効にするのが「Trusted Access」

**Trusted Access** = "Organizationsがこのサービスを信頼して組織全体の操作を許可する設定"

これをオンにしないと、StackSetsなどの自動デプロイ機能は動かない。

### StackSets = CloudFormationの「拡張版」

通常のCloudFormationは「1アカウント・1リージョン」にしか適用できない。
でも **StackSets** を使うと、複数アカウント × 複数リージョンに一括展開できる。

StackSetsでOrganizations配下の複数アカウントに自動デプロイ（OU単位で展開）したい場合は、「Trusted Access」を有効化して、「Service-managed」モードにする必要がある。

### 「Service-managed」モード

StackSetsには2つの権限モードがある：

| モード名 | 特徴 | 必要条件 |
|---------|------|---------|
| Service-managed（サービス管理型） | AWS Organizationsと連携。OU単位で自動デプロイ。新規アカウントにも自動反映。 | ✅ Trusted Accessを有効化する必要あり |
| Self-managed（自己管理型） | 各ターゲットアカウントに手動でAssumeRole設定。Organizations未使用でもOK。 | ❌ Trusted Access不要（でも自動化されない） |

---

# 災害対策（DR）戦略

## Pilot Light と Warm Standby の違い

Pilot Light と Warm Standby の違いは**「規模」と「稼働状態の範囲」**。

2つとも「災害対策（DR: Disaster Recovery）」の手法で、両方とも **常時2リージョンを使う** けれど、「DR側でどこまで動かしておくか」が決定的に違う。

### 視覚イメージ

**Pilot Light：**
```
  ┌──────────────┐        ┌──────────────┐
  │ 本番リージョン │──────▶│ DRリージョン   │
  │ すべて稼働中    │        │ 最小限の構成のみ│（🔥火種）
  └──────────────┘        └──────────────┘
```

**Warm Standby：**
```
  ┌──────────────┐        ┌──────────────┐
  │ 本番リージョン │──────▶│ DRリージョン   │
  │ すべて稼働中    │        │ 本番の縮小版も稼働中│（🔥🔥小規模稼働）
  └──────────────┘        └──────────────┘
```

### 比較表

| 項目 | Pilot Light | Warm Standby |
|------|-------------|--------------|
| 概要 | DR側は「最低限」だけ動かす | DR側に「縮小版の本番」を常時稼働 |
| DR側に常時あるリソース | DBのレプリカ、AMI、設定スクリプトなど | EC2, DB, アプリなどの本番構成を縮小して常時稼働 |
| 復旧時の手順 | 災害時にスクリプトやAuto ScalingでDR側を"起動・拡張" | すでに動いているDR側をスケールアップして切替 |
| 復旧時間（RTO） | 数十分〜数時間 | 数分〜数十分 |
| コスト | 中くらい（DR側は最小構成） | 高め（DR側も常時稼働） |
| データ同期 | レプリケーションやスナップショットで同期 | 同様（リアルタイム同期が多い） |
| DRリージョンの状態 | 「火種（Pilot Light）」状態 | 「小規模稼働中（Warm）」状態 |

### イメージ

| 構成 | Pilot Light の例 | Warm Standby の例 |
|------|-----------------|------------------|
| EC2 | AMIのみ保持。災害時に起動。 | 小さなEC2を常時稼働。 |
| RDS | リードレプリカ or スナップショット。 | RDSを常時同期して稼働。 |
| S3 | クロスリージョンレプリケーション | 同上 |
| Route53 | フェイルオーバールール定義のみ | 同上（DR側も常時監視） |

---

## DRにおける障害検知の仕組み

構成における"判断の仕組み"は主に3段階

| 検知レイヤー | 主な仕組み | 役割 |
|-------------|-----------|------|
| DNSレベル | Route 53 ヘルスチェック | 本番リージョンが応答しなくなったらDNSをDR側に切り替える |
| アプリ/監視レベル | CloudWatch アラーム、Lambda、自動通知 | メトリクス監視で異常を検知してアクションを実行 |
| 管理レベル | 手動 or 自動フェイルオーバースクリプト | 障害検知後にCloudFormationやMGNでDR環境を起動 |

### ① Route 53 ヘルスチェック（DNSレベル）

**仕組み：**

Route 53 が本番リージョンのエンドポイント（ALB, API, EC2 など）に定期的にリクエストを送る。
もし応答が途絶えたら、フェイルオーバールーティングポリシーで自動的にDRリージョンへトラフィックを切替。

```
Route53 Health Check → OK → 東京リージョンへルーティング
Route53 Health Check → NG → 大阪リージョンへルーティング（DR）
```

**メリット：**

- 完全自動でトラフィックを切り替えられる
- パイロットライトでもウォームスタンバイでも利用可能

---

### ② CloudWatch + Lambda（アプリ／監視レベル）

**仕組み：**

CloudWatchがメインリージョン内のアプリ／DBの状態を監視。
閾値を超えた場合（例：応答なし、CPU暴走など）に
SNS通知 → Lambda起動 → DR側起動スクリプト実行。

```
CloudWatch Alarm → SNS → Lambda →
  ① DR側CloudFormation Stackを起動
  ② Route53エントリをDRに変更
```

**メリット：**

- DNS以外の障害（アプリ異常、DB破損など）も検知可能
- 柔軟にフェイルオーバー制御ができる

---

### ③ 手動 or 自動スクリプトによるフェイルオーバー

Pilot Lightの場合は、DR側に「最小構成」しか動いていないため、"火を大きくする"（スケールアウト）動作が必要。

これを自動化するために：

- CloudFormation StackSets
- AWS Systems Manager Automation
- AWS MGN（Application Migration Service）

などを組み合わせ、Lambda経由で「障害発生 → DR側を起動」まで自動化。

---

# カスタム可用性メトリクス

## 前提：AWSの「可用性メトリクス」とは

AWSの **CloudWatch メトリクス** は、EC2、RDS、ALBなどのリソースの状態（CPU、ネットワーク、ステータスなど）を数値でモニタリングする仕組み。

でも、アプリの「本当に使えるか（可用性）」までは見れないことが多い。

### そこで出てくるのが「カスタム可用性メトリクス」

アプリやシステムの"実際の稼働状態"を自分で定義して、CloudWatchに送信するメトリクス
（＝CloudWatchの標準メトリクスにはない独自の「可用性」指標）

## どう使うのか（構成イメージ）

### 例：Webアプリの可用性を監視したい

**標準メトリクス：**

- EC2が起動してるか
- ALBが200を返しているか

→ これはインフラが生きてるだけの話。アプリ内部が落ちてても "OK" になってしまう。

**カスタム可用性メトリクスを使うと：**

自分のアプリに「可用性チェック用エンドポイント（/health など）」を用意して、Lambdaや監視スクリプトで定期的に呼び出す。

結果を CloudWatch に送信：

- レスポンス成功 → `Availability = 1`
- レスポンス失敗 → `Availability = 0`

これにより、**アプリレベルの可用性**を数値化してCloudWatchで監視・アラート設定が可能になる。

---

# AMI配布パターン（Image Builder + Service Catalog）

「中央チームがImage BuilderでAMIを自動生成 → Service Catalogで承認・配布 → OU全体で統一利用」という"セキュリティと効率を両立したAMI配布のパターン"

## 各サービスの役割

| サービス | 役割 |
|---------|------|
| EC2 Image Builder | セキュリティパッチ適用・ソフトウェア導入済みAMIを自動生成。定期更新も可。 |
| AWS Service Catalog | 「承認済みAMI」を製品カタログとして管理し、OU単位で共有できる。 |
| AWS Organizations | OUベースの共有・アクセス制御を簡略化。 |
| CloudFormation StackSets（補助的） | 各アカウントに自動的にCatalogを展開したい場合に利用。 |

## フロー図

```
[中央管理アカウント]（例：セキュリティOU配下）
      │
      │① EC2 Image Builder が定期的に最新のAMIを作成
      │
      │② AWS Service Catalog にポートフォリオとして登録
      │
      │③ AWS OrganizationsのOU単位でポートフォリオを共有
      │
      ▼
[各メンバーアカウント]
      │
      └─ Service Catalog から承認済みAMIを利用してEC2起動
```

---

# DynamoDB TTL（Time To Live）

DynamoDBの **TTL（Time To Live）** は、「指定した時刻を過ぎたら自動的にアイテム（行）を削除してくれる仕組み」。
つまり、ストレージの整理を自動化し、コストを削減する機能。

## 基本の仕組み

各アイテムに「TTL属性（例えば `expireAt`）」という**Unixタイムスタンプ（秒単位）**をセット。

**例：**

```json
{
  "deviceId": "A001",
  "timestamp": "2025-10-12T13:00:00Z",
  "temperature": 28.2,
  "expireAt": 1765640400  // ← 2026年1月13日 00:00:00 のUnix時間
}
```

DynamoDBはバックグラウンドでこの`expireAt`を定期的にチェックし、期限を過ぎたアイテムを自動的に削除。

## 削除のタイミング

| 項目 | 内容 |
|------|------|
| 削除タイミング | TTLの時刻を過ぎてから最大48時間以内（保証はリアルタイムではない） |
| 課金 | TTL削除されたアイテムの削除処理は無料（Write Capacityも消費しない） |
| Streams | DynamoDB Streamsを有効にしておけば、削除イベントを他の処理に使える（例：S3バックアップなど） |

## ユースケース

### 一時セッションやキャッシュデータ

ログインセッション、ワンタイムトークン、短期的なAPIキャッシュなどにも使える。

**まとめ：**TTLは「削除ジョブいらずでストレージコストを自動最適化する仕組み」。

---

# S3 Replication Time Control (RTC)

S3 Replication Time Control (RTC) は、AWSが提供する **S3の高信頼レプリケーション機能** で、「データを15分以内に必ず複製することをSLAで保証」する、S3レプリケーションの上位機能。

通常のS3レプリケーション（CRR / SRR）は「非同期で最終的に複製される」だけで、時間の保証（SLA）はない。

一方、**Replication Time Control (RTC)** を有効化すると：

**99.99% のオブジェクトを15分以内に複製完了（AWSが公式にSLAとして保証）**

が実現される。

## 機能の仕組み

S3 RTCは、以下のコンポーネントで構成：

| 機能 | 内容 |
|------|------|
| Replication metrics | CloudWatchで「複製遅延」や「未複製バイト数」を可視化できるメトリクス |
| Event notifications | レプリケーション進行イベントを EventBridge 経由で検出・通知可能 |
| SLA | 99.99% のオブジェクトを15分以内に複製（15分超過はEventBridgeで通知） |

## 設定時の主なポイント

1. 既存のS3レプリケーションルール（CRRまたはSRR）を作成
2. RTCを有効化
3. CloudWatchメトリクスを有効化
4. EventBridgeルールを作成
5. `MaxReplicationTime > 900秒` をトリガーにSNS通知を送信（例：SLA超過検知）

## 暗号化との組み合わせ（KMS再暗号化）

RTCは **SSE-KMS** 暗号化バケットとも連携できる。
クロスアカウント・クロスリージョンでも、「宛先側で別のKMSキーを使って再暗号化」することが可能。

## CloudWatch メトリクス例

| メトリクス名 | 意味 |
|-------------|------|
| BytesPendingReplication | まだ複製されていないデータ量 |
| OperationsPendingReplication | 未完了のレプリケーション処理数 |
| MaxReplicationTime | 最も遅いレプリケーションの経過時間（秒） |

## タグベースフィルタリング

RTCはタグベースでもルールを制御できる。

**例：**「タグ `regulated=true` のオブジェクトだけをRTC対象にする」

```yaml
Filter:
  Tag:
    Key: regulated
    Value: true
```

---

# AWS DataSync

DataSyncエージェントは「AWS外のシステム（オンプレや他クラウド）」とAWSを安全に結ぶための**転送エンジン（TLSトンネル）**。

なので、AWSのマネージドサービス同士（S3やEFS、FSxなど）では、AWS内部ネットワークを使って転送できるため、**エージェント不要**。

---

# IAM条件キー（aws:PrincipalTag）

## タグベースのAssumeRole制御

`Department=Finance` タグを持つロールだけがAssumeRoleできるようにする

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": { "AWS": "arn:aws:iam::111122223333:root" },
      "Action": "sts:AssumeRole",
      "Condition": {
        "StringEquals": {
          "aws:PrincipalTag/Department": "Finance"
        }
      }
    }
  ]
}
```

### 意味

アカウント `111122223333` の中にあるIAMロール・ユーザーのうち、タグ `Department=Finance` が付与されているものだけがこのロールを引き受け可能。

## 応用的な例

たとえば、呼び出し元のロールと引き受け先のロールのタグを照合することもできる：

```json
"Condition": {
  "StringEquals": {
    "aws:PrincipalTag/Environment": "${aws:ResourceTag/Environment}"
  }
}
```

---

# クロスアカウントAssumeRole

## AssumeRoleのクロスアカウント利用は "両想い設定" が必要

| 設定場所 | ポリシーの種類 | 目的 |
|---------|--------------|------|
| ✅ 呼び出し元アカウント（A） | 権限ポリシー | 「このロールを引き受ける（sts:AssumeRole）ことを許可」 |
| ✅ 引き受け先アカウント（B） | 信頼ポリシー | 「この呼び出し元に引き受けられてもOK」と信頼を与える |

### どっちの設定も必要な理由

| ポリシー | なぜ必要か |
|---------|-----------|
| 呼び出し元の権限ポリシー | 「AssumeRoleアクションを実行する権限」が必要。なければAPI自体呼べない。 |
| 引き受け先の信頼ポリシー | 「誰にこのロールをAssumeさせていいか」を決める。なければ拒否される。 |

---

# AWS CLI 認証の仕組み

## AWS CLI の動作ルール

AWS CLI はコマンドを実行するとき、以下の順番で認証情報を探す：

1. **環境変数**
   - `AWS_ACCESS_KEY_ID`
   - `AWS_SECRET_ACCESS_KEY`
   - `AWS_SESSION_TOKEN`

2. **AWS CLIのプロファイル設定**（`~/.aws/credentials`）

3. **EC2インスタンスのIAMロール**

なので、

- 今は「環境変数が最優先されている」状態。
- その環境変数にSTSトークンを設定しているから、Assumeしたロールとして動いている。

### セッショントークンの有効期限

この環境変数で使ってるSTSトークンは、通常 **1時間（3600秒）で期限切れ**。

---

# CloudFormation Stack vs StackSets

## 通常の スタック（Stack）

これはおなじみの CloudFormation。

**「1つのアカウント・1つのリージョン にリソースをデプロイ」**する仕組み。

## スタックセット（StackSets）

StackSets はこの CloudFormation を拡張したもの。

**「複数のAWSアカウント や 複数リージョン に一括で同じスタックを展開」**できる。

### 比較表

| 項目 | Stack（通常） | StackSets（拡張版） |
|------|-------------|-------------------|
| スコープ | 単一アカウント・単一リージョン | 複数アカウント・複数リージョン |
| 主な用途 | アプリやインフラを個別にデプロイ | 組織全体への一括展開 |
| 必要な設定 | CloudFormationテンプレートのみ | Trusted Access + IAMロール |
| 管理単位 | 各アカウント | 管理アカウント（Organizations統括） |
| 主な利用例 | EC2, S3, VPCなどを個別作成 | ログバケット、監査設定、共通IAMロールを全アカウント展開 |

## StackSetsでの動的命名

複数アカウント・リージョンに展開する際、名前の衝突を避けるために動的に命名：

```yaml
BucketName: !Sub 'stacksets-demo-${AWS::AccountId}-${AWS::Region}'
```

この `!Sub` は CloudFormation の組み込み関数で、文字列の中にある `${}` の部分を その時点の環境情報で自動置換。

### 具体的には

| 変数 | 展開される値 | 例 |
|------|-------------|---|
| `${AWS::AccountId}` | スタックを実行しているアカウントのID | 123455667 |
| `${AWS::Region}` | スタックを実行しているリージョン | ap-northeast-1（東京） |

### StackSets の場合はどうなるか

StackSets は、指定した OU（組織単位）配下の各アカウントに同じテンプレートをデプロイ。

つまり：

- OU配下のアカウント A → `${AWS::AccountId}` = 239857123343
- OU配下のアカウント B → `${AWS::AccountId}` = 111122223333

のように、各アカウントで自動的に固有の値が入る。

---

# CloudFormationで作成できるIAM関連リソース

CloudFormationでは、以下のようなIAM構成要素を普通に定義できる。

| リソースタイプ | 例 | 補足 |
|--------------|----|----|
| AWS::IAM::Role | IAMロール（EC2用ロールなど） | 代表的。AssumeRolePolicyDocumentも記述可能。 |
| AWS::IAM::Policy | カスタムポリシー | ロール・ユーザー・グループにアタッチできる。 |
| AWS::IAM::User | IAMユーザー | あまりStackSetsでは使わない（ベストプラクティス的に非推奨）。 |
| AWS::IAM::Group | IAMグループ | 同上。 |
| AWS::IAM::InstanceProfile | EC2インスタンスプロファイル | ロールとセットで使う。 |
