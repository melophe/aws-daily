# タグポリシーの概要

タグポリシーは、**AWS Organizations 管理アカウント（または委任された管理アカウント）**から
全アカウントに対して「タグ命名ルール」や「許可値の制約」を配布する仕組み。

## どこで設定するか

設定場所：
AWS Organizations コンソール → [ポリシー] → [タグポリシー]

または AWS CLI / SDK からも設定可能。

## 適用範囲

タグポリシーは次の単位でアタッチ可能：

| 適用対象 | 意味 |
|---|---|
| Root | 全組織のアカウントに適用 |
| OU（組織単位） | 特定部門（例：財務、開発）に適用 |
| 個別アカウント | 特定アカウントのみに適用 |

## ポリシー例

```json
{
  "tags": {
    "BusinessCode": {
      "tag_key": {
        "@@operators_allowed_for_child_policies": ["=="]
      },
      "enforced_for": ["ec2:instance", "s3:bucket"],
      "tag_value": {
        "@@operators_allowed_for_child_policies": ["=="],
        "@@assign": ["FIN001", "HR002", "ENG003"]
      }
    }
  }
}
```

この設定を OU 単位でアタッチすれば、

「Finance OU」には FIN001 のみ許可、

「HR OU」には HR002 のみ許可、
といった制御も可能。

## タグポリシーの特性

タグポリシーは 「検出型 (Detective Control)」。
- 違反しても作成自体はブロックされない（レポートで検知する）
- AWS Resource Explorer や AWS Resource Groups で「タグ準拠状況」を確認可能
- 予防的制御をしたい場合は、SCP や CloudFormation Hook と併用が必要

## 関連サービス比較

| 機能 | タイプ | 役割 |
|---|---|---|
| タグポリシー | 検知型 | 組織全体の標準タグルール定義 |
| SCP（Service Control Policy） | 予防型 | 不正タグ値を持つリソース作成を拒否 |
| AWS Config | 検知＋是正 | 定期的に違反タグを監視・修正 |
| CloudFormation Hooks | 予防型 | デプロイ時にテンプレートのタグ検証 |

**補足:**
- タグポリシー：ルールを「宣言」して可視化・検知する（Organizationsレベル）
- AWS Config：実際のリソースを「スキャン」して準拠・非準拠を評価する（アカウントレベル）

---

# EC2 Auto Scaling - Instance Requirements

EC2 Auto Scaling グループで "インスタンスタイプを固定せず、属性で指定する" 機能。

## 正式名称

- **Instance Requirements（インスタンス要件）**
- または
- **Attribute-based instance type selection（属性ベースのインスタンスタイプ選択）**

## 従来の方法

```yaml
InstanceType: m5.large
```

## 新しい方法

```yaml
InstanceRequirements:
  VCpuCount:
    Min: 2
    Max: 4
  MemoryMiB:
    Min: 4096
    Max: 8192
  BurstablePerformance: excluded
  CpuManufacturers: [intel, amd]
  InstanceGenerations: [current]
  LocalStorage: required
```

AWS がこの条件を満たすインスタンス（例: m6a.large, t3.xlarge, c6i.large など）を自動で選んで起動。

## vCPU とは

vCPU（仮想CPU） は m5.large などの インスタンスタイプの中身（性能構成の一部） を構成する要素。

| インスタンスタイプ | vCPU数 | メモリ | 備考 |
|---|---|---|---|
| t3.micro | 2 | 1 GB | 軽量用途 |
| m5.large | 2 | 8 GB | 汎用 |
| m5.xlarge | 4 | 16 GB | 汎用（倍性能） |
| c5.2xlarge | 8 | 16 GB | CPU重視 |
| r5.2xlarge | 8 | 64 GB | メモリ重視 |

## 具体例

以前は「m5.large」みたいに名前で固定していたが、今は「中身（vCPU・メモリ）」で条件指定できる。

```yaml
InstanceRequirements:
  VCpuCount:
    Min: 2
    Max: 4
  MemoryMiB:
    Min: 4096
    Max: 8192
```

と書くと、AWS が "m5.large" か "m6i.large" か "c6a.large" など、条件を満たすインスタンスを自動で選んで起動してくれる。

---

# Aurora Global Database

## 仕組み

### 特徴

- 1つのプライマリリージョンが書き込み担当
- 最大5つのセカンダリリージョンが読み取り専用
- ストレージ層（物理レベル）でレプリケーションしているため高速

### フェイルオーバー

- プライマリ障害時には、セカンダリをプライマリに昇格可能
- 数分でリージョン切り替え完了

---

# DynamoDB Global Table

## 仕組み

### 特徴

- 全リージョンが書き込み可能（マルチマスター）
- 変更は他リージョンにも非同期で伝播
- NoSQLなのでスキーマレス・超高速

### データ整合性

- 書き込み競合時は「Last writer wins」（最後の更新が優先）
- 衝突検出・解決は自動処理（DynamoDB側で管理）

## 比較表

| サービス | 特徴 |
|---|---|
| Aurora Global DB | 「1つのマスターDBを各リージョンに複製して読む」 |
| DynamoDB Global Table | 「すべてのリージョンで同時に書き込める分散DB」 |

---

# CloudFront Function と Lambda@Edge

## CloudFront Function の使用例

CloudFront Function（または Lambda@Edge）が「正しい順序」に変換する例：

| ユーザーが送ったURL | CloudFront Function後のURL |
|---|---|
| ?Color=Black&Category=Shoes | ✅ ?category=shoes&color=black |
| ?category=Shoes&color=Black | ✅ ?category=shoes&color=black |
| ?category=shoes&Color=black | ✅ ?category=shoes&color=black |

## Lambda@Edge と CloudFront Function の関係

| 項目 | Lambda@Edge | CloudFront Function |
|---|---|---|
| 実行タイミング | Viewer / Origin Request / Response すべてOK | Viewer Request / Viewer Response のみ |
| 実行場所 | Edgeロケーション（AWS Lambda環境） | CloudFrontのエッジ（より近い軽量ランタイム） |
| コスト | 高め | 安い（1/10〜1/100） |
| 処理時間 | 数ms〜数百ms | 数μs（マイクロ秒！） |
| 実行制限 | 最大数秒までOK（Node.js環境） | 軽量処理のみ（CPU・メモリ制限あり） |
| デプロイ | 少し時間がかかる（リージョン間複製あり） | 即時反映（数秒） |

## Lambda@Edge とは

Amazon CloudFront に紐づけて使う "サーバーレス関数"。

- 世界中の CloudFront エッジロケーションで動作
- HTTPリクエスト／レスポンスを動的に操作できる
- AWS Lambda の機能を、CloudFront の「手前」や「裏側」に配置できるようにしたもの

## Lambda@Edge が使える 4 つのイベントフェーズ

CloudFront のリクエストフローには 4つのタイミングがあり、
Lambda@Edge はすべてのフェーズで動かせる👇

| イベント | タイミング | 説明 |
|---|---|---|
| Viewer Request | ユーザー → CloudFront の直前 | ユーザーからのリクエストを受けた時。リダイレクトや認証に使う。 |
| Origin Request | CloudFront → オリジンの直前 | オリジンに渡す前にリクエストを変更（例：ヘッダー追加など）。 |
| Origin Response | オリジン → CloudFront の直後 | オリジン応答を加工（例：HTML書き換え、圧縮）。 |
| Viewer Response | CloudFront → ユーザーの直前 | レスポンスヘッダーを追加、Cookie設定など。 |

## まとめ

- **CloudFront Function**: 軽くて速い、キャッシュキーやリクエスト整形用
- **Lambda@Edge**: 重いけど何でもできる、認証や動的レスポンス処理用

---

# Aurora - 5ノード構成

## 5ノード構成とは

次のような構成：

| 種類 | 数 | 役割 |
|---|---|---|
| Writer instance | 1 | 書き込み・読み込み両対応 |
| Reader instance | 4 | 読み取り専用、負荷分散＆高可用性 |

---

# AWS Migration Hub

AWS Migration Hub（マイグレーションハブ） は、AWSへの移行プロジェクトを「全体的に見える化・管理」するための統合サービス。
単に「移行ツール」ではなく、移行の司令塔（ハブ） のような存在。

## アーキテクチャ図

```
[Discovery Agent]──┐
[Migration Evaluator]│
[Server Migration Service]│
[Application Migration Service]│
[Database Migration Service]──┘
           │
           ▼
   [AWS Migration Hub]
           │
           ▼
   結果の可視化・依存関係分析・進捗追跡
```

AWS Migration Hub は、アプリケーション移行の進捗・依存関係・コスト見積・戦略決定を一元管理するサービス。

**つまり:**

「どのサーバーを」「どうやって」「どの順に」移行すればいいか
を整理・計画・追跡するための"コントロールセンター"。

## 主な機能一覧

| 機能名 | 内容 | 主な利用タイミング |
|---|---|---|
| Application Discovery Service (ADS) | オンプレ環境のサーバー・プロセス・通信データを収集。 | 現状調査（ディスカバリ） |
| Dependency Mapping | 通信関係（どのサーバーがどのサーバーと話しているか）を可視化。 | 依存関係分析 |
| Migration Hub Strategy Recommendations | 各アプリを「リホスト／リプラットフォーム／リファクタ」など分類提案。 | 戦略立案 |
| Migration Tracking | DMS・Application Migration Service などの移行進捗を統合管理。 | 実行・監視 |
| Grouping (移行ウェーブ) | 同時に移行すべきサーバー群をグループ化。 | 計画設計 |
| Integration | 他AWSサービス（DMS、Application Migration Serviceなど）と自動連携。 | 全体統制 |

## Discovery Agent の仕組み

```
[オンプレサーバー群]
 ├─ Application Discovery Agent（各サーバーにインストール）
 │     ├─ OS情報
 │     ├─ プロセス情報
 │     ├─ ネットワーク通信(ポート8765など)
 │     └─ 使用CPU/メモリなどのメトリクス
 │
 └─────▶ データ収集 ▶ AWS Application Discovery Service
                         │
                         ▼
                 [AWS Migration Hub]
                         │
                         ├─ サーバー一覧の自動登録
                         ├─ 依存関係のマッピング
                         ├─ グルーピング（移行ウェーブ）
                         └─ Strategy Recommendations（移行戦略提案）
```

## よくある誤解

**Discovery Agentを入れたら移行できる？**
❌ データ収集専用。移行自体は別サービスで行う（MGN, DMSなど）

---

# API Gateway と Lambda の接続方法

API Gateway と Lambda の接続方法には、実は2種類ある。

## 統合方法の比較

| 種類 | 名前 | 特徴 |
|---|---|---|
| ① Lambda プロキシ統合 | Lambda Proxy Integration | API Gatewayが受け取ったHTTPリクエスト全体（メソッド・ヘッダ・ボディなど）をそのままLambdaへ渡す。レスポンスもLambdaが直接返す。最もシンプル。 |
| ② Lambda カスタム統合（非プロキシ） | Lambda Custom Integration | API Gatewayがマッピングテンプレートを使って、リクエストを整形してLambdaに渡す。柔軟だが設定が面倒。 |

## 顧客ごとのリクエスト制限

- ✅ Usage Plan（利用プラン） でクォータ＋スロットリング設定
- プレミアム顧客に多めのリクエスト枠
- ✅ Usage Planを複数用意（Free / Standard / Premiumなど）

## ① Lambda プロキシ統合

- API Gateway が受けた HTTP リクエスト全体を Lambda に渡す
- Lambda 側は event からメソッド、ヘッダ、ボディなどを直接参照できる
- マッピングテンプレート不要、設定が超シンプル
- 開発スピードが速い・保守も容易

## ② Usage Plan（利用プラン）

クォータ（期間あたりの総リクエスト数）とスロットリング（秒あたりリクエスト数）を定義。

**例:**

- **Free Plan**: 月1000リクエスト、1秒あたり5件
- **Pro Plan**: 月10000リクエスト、1秒あたり50件
- **Premium**: 月100000リクエスト、1秒あたり200件

各プランを API Key と紐づけて顧客ごとに適用。

## ③ API Key

顧客を識別するための一意キー。

リクエストヘッダに含めて送信：
```
x-api-key: AbCd
```

API Gateway が Usage Plan と照合して、制限を適用。

### API Gateway が発行するAPI Keyとは

- 各顧客やクライアントごとに 一意なキー（英数字のランダム文字列）を生成
- AWSコンソールまたはCLI/SDKから簡単に作成できる
- そのキーを「Usage Plan（利用プラン）」に紐づけることで、クォータ（1日・1月あたりの上限）やスロットリング（リクエスト/秒）を自動で制御できる

### API リクエストのクォータとは

「このプランの人は1日あたり何回までAPI叩けますよ」という回数制限ルールのこと。

| プラン名 | クォータ (Quota) | スロットリング (Throttling) |
|---|---|---|
| Free Plan | 1,000リクエスト / 月 | 5リクエスト / 秒 |
| Pro Plan | 10,000リクエスト / 月 | 50リクエスト / 秒 |
| Premium Plan | 無制限 | 200リクエスト / 秒 |

### クォータ設定の単位

API Gatewayのクォータ設定では、次の単位を指定できる：

- 日単位（per day）
- 週単位（per week）
- 月単位（per month）

例えば：
- 「月に1000回まで」
- 「1日あたり200回まで」
- 「週に5000回まで」

といった形で設定。

### クォータとスロットリングの違い

| 機能 | 内容 | 目的 |
|---|---|---|
| クォータ (Quota) | 一定期間あたりの 総リクエスト数上限（例: 1日1000回） | 利用制限・課金プラン管理 |
| スロットリング (Throttling) | 一定時間あたりの リクエスト速度制限（例: 1秒5回） | 負荷制御・DoS対策 |

---

# LambdaなしでもAPIを作れる2つのパターン

## ① HTTP統合 (HTTP Proxy Integration)

外部APIや社内のRESTエンドポイントにそのままリクエストを転送。

```
API Gateway → https://example.com/internal-api
```

API Gatewayがリクエストを受けて、外部のAPIにそのままHTTP転送してレスポンスを返す。

（このときもクォータやAPIキーは有効）

## ② AWSサービス統合 (AWS Service Integration)

AWSのサービスを直接呼び出すこともできる。

**例:**

- API Gateway → S3のGetObject 実行
- API Gateway → DynamoDBのQuery 実行
- API Gateway → Step FunctionsのStartExecution

つまり、Lambdaを介さずにAWSリソースを直接操作できる。

## ユースケース別の選択

| ユースケース | Lambda必要？ | 推奨方法 |
|---|---|---|
| S3のファイルをダウンロードさせたい | ❌ | API Gateway → S3統合でOK |
| 外部REST APIに転送したい | ❌ | HTTP統合でOK |
| DynamoDBをクエリしたい | ❌ | AWS統合でOK |
| カスタム処理（計算・DB集計・認証ロジックなど） | ✅ | Lambdaプロキシ統合を使う |

---

# AWS Application Migration Service (MGN)

AWS Application Migration Service (MGN) は、オンプレや他クラウドのサーバーを「そのままAWS EC2に移行」できるサービス。

- ダウンタイム最小
- 設定自動化
- 数百台でも一括対応可能

## 特徴

既存サーバーを Amazon EC2 に"そっくりそのまま"移行する（Lift & Shift）

### MGNのターゲットは「サーバーOSごと」

- ファイルサーバー、アプリサーバー、DBサーバーなど
- すべて「OSレベルでEC2に変換」する
- MGNは アプリケーション単位 ではなく、**サーバー単位（マシン単位）** でレプリケーション

## 移行サービスの使い分け

| 移行対象 | 使用サービス |
|---|---|
| サーバー（OSごと移行） | Application Migration Service (MGN) |
| データベース | Database Migration Service (DMS) |
| ファイルサーバー | DataSync + FSx for Windows File Server |
| VMware環境まるごと | VMware Cloud on AWS |

### ファイルサーバー移行

**AWS DataSync + FSx for Windows File Server**
- SMB/NTFS互換のファイル共有をそのままクラウド化

---

# VM Import/Export

VM Import/Export は、オンプレのVMイメージをAmazon EC2のAMIとしてインポートしたり、逆にエクスポートする機能。

| 方向 | 名前 | 説明 |
|---|---|---|
| 🡅 | VM Import | オンプレVM（例：.vmdk, .vhd, .ova）をAWSにアップロードし、EC2 AMI（マシンイメージ） に変換する |
| 🡇 | VM Export | AWS上のEC2インスタンスを オンプレ用の仮想マシン形式（VMDK/VHD） にエクスポートして戻す |

**注意:**
- VM Import/Export は、AWS Application Migration Service（MGN）よりも時間がかかり、手間も多い

