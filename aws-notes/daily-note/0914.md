# WAF GeoMatch 条件による地域制限

## GeoMatch 条件でできること

リクエスト元の国コード（ISO 3166-1 alpha-2）に基づいてアクセスを制御

### 設定例
- JP, US, DE 以外はブロック
- CN からのアクセスはブロック

---

## ルールアクション

設定可能なアクション：

### Allow（許可）
指定した国からのアクセスを許可

### Block（拒否）
指定した国からのアクセスを拒否

### Count（計測のみ）
アクセスをブロックせず、ログに記録のみ

---

## 適用方法

### 設定手順
1. WAF Web ACLを作成
2. GeoMatch条件をルールに追加
3. ルールのアクションをBlockに設定
4. Web ACLをALBやCloudFrontにアタッチ

---

## 制限事項と注意点

### 制限事項
WAFはIPレベルで判定するため、VPNやプロキシを使用されると完全に防ぐことは困難

### 現実的な効果
特定の国からのアクセスを大幅に制限するには最も現実的な方法

---

## 他サービスとの比較

### Route 53
- 機能: 振り分けは可能
- 制限: ブロックはできない

### ブロック実装の推奨方法
ALB / CloudFrontにWAFをアタッチしてGeoMatch条件を使用

---

## まとめ

### GeoMatch条件の特徴
- 国コードベースのアクセス制御
- Allow/Block/Countアクションが選択可能
- WAF Web ACLを通じてALB/CloudFrontに適用

### 使用場面
- 地域限定サービスの提供
- 特定国からの攻撃対策
- コンプライアンス要件への対応

---

## Route 53 vs WAF の役割

### Route 53
どこに行かせるかを決める

### WAF
行かせる/行かせない（ブロック）を決める

---

## S3 デフォルトのバケットポリシー

### S3バケット作成直後の状態
バケットポリシーは空（何も設定されていない）

### アクセス制御の仕組み
「アクセスはIAMに完全依存」

- IAMユーザー / IAMロールに適切なポリシーがあればアクセス可能
- バケットポリシーがなくても、IAMで許可されていればアクセス可能

---

## EC2からS3へのアクセスケース

### 基本構成
EC2インスタンス → S3 にアクセス

### 必要な設定
EC2インスタンスにIAMロールを付与するだけでS3バケットにアクセス可能

### バケットポリシーの必要性
必須ではない

---

## S3のアクセス制御は2段階

### 1. IAMポリシー（EC2にアタッチしたIAMロール）
「誰がアクセスできるか」を決定

### 2. バケットポリシー（任意）
「このバケットは誰からのアクセスを受け入れるか」を制御

---

## デフォルト状態のS3バケット

### 状態
- バケットポリシー = 空（何も記述されていない）
- 「IAMで許可されているならアクセスできる」状態

### 実装方法
EC2にIAMロールをアタッチし、そのロールにs3:PutObjectやs3:GetObjectの権限を付与

---

## EBSボリュームタイプ比較表

| タイプ | 用途 | IOPS性能 |
|--------|------|----------|
| gp2 | 汎用SSD（従量制） | 3 IOPS/GB、最大 16,000 |
| gp3 | 汎用SSD（最新推奨） | 最大 16,000（容量と独立） |
| io1/io2 | 高性能SSD | 最大 64,000 |
| io2 Block Express | 超高性能SSD | 最大 256,000 |
| st1 | HDD（スループット重視） | 数千程度（最大500 MB/s） |
| sc1 | HDD（低コスト） | 数百程度（最大250 MB/s） |

---

## 用途別選択指針

### IOPS重視
io1/io2

### コストバランス
gp3

### 大容量スループット
st1

### 低頻度/低コスト
sc1

---

## Aurora レプリカ

### 仕組み
Auroraは分散ストレージ層を共有しており、レプリカも同じストレージを参照

### 特徴
- 遅延がほぼゼロ（ストレージを直接参照するため）
- フェイルオーバーが高速（数十秒以内で完了）
- ストレージはクラスター全体で共有、コピー不要

---

## Aurora のフェイルオーバー時間

### Aurora (シングルマスター構成)

#### 標準的な時間
- 通常は30秒前後
- 場合によっては20〜50秒程度
- AWS公式も「一般的に30秒未満」と説明

#### 最大時間
最長で1分弱（60秒程度）かかることもある

---

## RDS のフェイルオーバー時間

### RDS (従来のMySQL/PostgreSQL)

#### 標準的な時間
一般的に1〜2分程度

#### 最大時間
条件によっては3〜5分かかるケースもある

#### 時間がかかる理由
- プライマリが停止したらスタンバイに昇格
- ストレージの切り替え・同期処理が必要
- DNSの更新などが必要

---

## 設計上の考慮点

### Aurora
一般的には30秒以内だが、最悪で60秒程度は見込んで設計する必要

### RDS
1〜2分（場合によっては数分）かかるため、ストレージ同期やレプリカ昇格の時間を考慮

---

## まとめ

RDSのフェイルオーバーは1〜2分（場合によっては数分）、Auroraは30秒前後

---

## Lambda が「微妙」なケース

### 常時トラフィックがある場合
- Lambdaはイベント駆動型で「使った分だけ課金」が強み
- 24時間ずっと負荷がかかるならEC2やECS/Fargateの方がコスパが良い
- 呼び出し課金が積み重なる上、コールドスタートのオーバーヘッドもある

### 長時間トランザクション
- Lambdaは実行時間の上限がある（現在は15分）
- トランザクション処理が長い・継続的な場合は不向き

### 状態を持つ処理が必要
- Lambdaは基本ステートレス
- セッション管理やコネクション維持が必要なら工夫が必要

---

## Lambda が向いているケース

### イベントが突発的・バースト的に発生する場合
例：画像アップロード → 変換処理

### 利用時間が短い場合
例：1日に数百回程度の処理

### スケーリングを自分で管理したくない場合
自動で並列処理が可能

---

## 高トランザクション処理の推奨アーキテクチャ

「常時リクエストがあるREST API」かつ「高トランザクション処理」の場合：
- Lambdaはコスト的にも安定性の面でも不利
- SQS + EC2 (AutoScaling) でワークロードを分散させる方がベスト

---

## Auto Scaling ポリシーとSQSの関係

### 処理フロー
1. トランザクションリクエスト → Amazon SQSキューに蓄積
2. EC2インスタンス群がキューからメッセージを取り出して処理
3. CloudWatchメトリクスでSQSの状態を監視

### 監視メトリクス
- ApproximateNumberOfMessagesVisible：キューに蓄積されている未処理メッセージ数
- ApproximateNumberOfMessagesDelayed：遅延中のメッセージ数
- ApproximateAgeOfOldestMessage：一番古いメッセージの滞留時間

### Auto Scaling ポリシー設定例
- キューに100件以上蓄積されたらEC2を2台増やす
- 古いメッセージの待ち時間が60秒を超えたらEC2を追加

### メリット
トラフィックが急増してもSQSがバッファになるため「中断されない継続的処理」が可能

Auto Scalingの指標はCPU使用率ではなく、SQSキューのメトリクスを使用するのがベストプラクティス

---

## Auto Scaling の基本概念

### スケーリングメトリクス (Scaling Metrics)
スケーリングの基準にする指標

#### 例
- EC2のCPU使用率
- ネットワークI/O
- SQSのApproximateNumberOfMessagesVisible（未処理メッセージ数）
- ALBのリクエスト数

### スケーリングポリシー (Scaling Policy)
「そのメトリクスをどう使ってスケールさせるか」のルール

#### 例
- ターゲット追跡スケーリング（メトリクスを一定値に保持）
- ステップスケーリング（しきい値を超えたら段階的に増減）

---

## パーティションの概念

### パーティションのイメージ
- 物理ディスク（EBSボリューム）= 大きな空き箱
- パーティション = その箱を仕切る区切り

### 例
100GBのEBSを作成した場合：
- その100GBをまるごと1つの領域として使用
- または40GB + 60GBに分けて「別のディスク」としてOSに認識させる

---

## パーティションとファイルシステムの関係

### 処理の流れ
1. EBSボリューム（ディスクそのもの）
2. パーティションを作成（区切りを作る）
3. 各パーティションにファイルシステムを作成（ext4, xfs等）
4. マウントして使用

ファイルシステムを作成する = 「ボリュームをOSが理解できる形式に初期化する」こと

EBSは「まっさらなディスク」で届くので、Linuxなら mkfs で ext4 や xfs を作ってからマウントする必要がある

---

## 実際のAWS運用での考慮点

### 一般的な運用
新規EBSを「丸ごと1つの領域」として使用することが多い

この場合はパーティションを作成せずに直接ファイルシステムを作成することも可能
例：`mkfs.ext4 /dev/xvdf` をそのまま実行

### 複数パーティション分割が必要なケース
古い慣習や特殊要件があれば `fdisk` で区切る

---

## マウントターゲット

### 概要
Amazon EFS (Elastic File System) で使用する用語

---

## KMS と S3 の関係

### SSE-KMS 暗号化
S3のSSE-KMS暗号化を使用すると、オブジェクトはKMSキーで暗号化される

### 読み出しに必要な権限
データを読み出すには以下2つの権限が必要：
- S3側の権限（例：s3:GetObject）
- KMS側の権限（例：kms:Decrypt）

両方が揃って初めてデータの中身が復号されて返される

---

## 読み取りトラフィックのオフロード

### 概念
プライマリDBに集中している「読み取りリクエスト」を、別のサーバー（リードレプリカ等）に肩代わりさせること

---

## RDS のマルチAZ

### 基本構成
- プライマリDBインスタンス（Writer）を1つ用意
- AWSが自動でスタンバイDBインスタンスを別のAZに作成
- 同期レプリケーションによりデータは常にほぼリアルタイムでコピー

### 障害時の動作
障害時（インスタンス障害、AZ障害、メンテナンス等）が発生すると：
1. 自動的にスタンバイがプライマリに昇格
2. Route53のCNAME（DBエンドポイント）が新しいプライマリを指すように切り替え
3. アプリケーションは同じ接続文字列で継続利用可能

### スタンバイの制限事項
- スタンバイは読み取り不可
- Auroraと違い、スタンバイをSELECT用に使用することはできない
- あくまで「災害対策用の待機機」

### 特徴
- フェイルオーバー時間は1〜2分程度
- コストは2倍近くなる（スタンバイにも料金が発生）
- 自動化されているので運用は簡単

---

## RDS マルチAZ構成の詳細

### プライマリ（Writer）
書き込み・読み取りどちらも受け持つ

### スタンバイ（Standby）
- 同期レプリケーションで常にプライマリのコピーを保持
- 普段はまったく使用できない（SELECTすらできない）
- あくまで「障害時にフェイルオーバーで昇格するための待機機」

---

## Aurora との対比

### RDS マルチAZ
スタンバイは「保険用」のみで読み取り不可

### Aurora
Aurora Replicaを別AZに配置すれば、普段はSELECTに使用でき、障害時はWriterに昇格

---

## RDS リードレプリカ

### 概要
非同期レプリケーション（MySQL/PostgreSQL のレプリケーション機能を利用）

プライマリからレプリカにデータをコピーして 読み取り専用 (SELECT) が可能

### ユースケース
読み取り負荷分散 や 分析用DB

### 特徴
- 複数のリードレプリカを作れる（最大5台程度、Auroraはもっと多い）
- レプリカを「昇格」してプライマリにすることも可能（手動/自動化スクリプト）

---

## RDS 構成比較

### RDS マルチAZ（スタンバイレプリカ）
- 役割：DR対策（高可用性 / フェイルオーバー）
- 同期レプリケーション
- 読み取りできない（完全に待機専用）

### RDS リードレプリカ
- 役割：性能改善（読み取りオフロード）
- 非同期レプリケーション
- 読み取り専用で最大5台まで作成可能

---

## Aurora 構成の特徴

### Aurora Replica
- 同じ仕組みで 読み取り分散 (Read Replica) にも使えるし、障害時の自動フェイルオーバー先 (Standby) にもなる
- Aurora ストレージ層（6コピー/3AZ分散）がベースにあるので、インスタンスは「計算リソース（コンピュート）」として追加・削除できるイメージ
- 最大 15 台まで Aurora Replica を作成可能（RDS より多い）

1種類の Replica が「スタンバイ（DR）」と「読み取りオフロード（性能改善）」の両方を兼ねている

---

## 構成比較まとめ

| 項目 | RDS | Aurora |
|------|-----|--------|
| DR対策 | マルチAZ (スタンバイ) | Aurora Replica (自動フェイルオーバー対象) |
| 読み取り性能改善 | リードレプリカ | Aurora Replica (読み取り専用にも使える) |
| レプリカ数 | リードレプリカは最大5台 | 最大15台 |
| 特徴 | HA用とスケール用が別 | 1種類のReplicaが両方の役割を担う |

---

## インスタンス・ストレージ構成

### RDS の場合

#### リードレプリカ作成時
- インスタンスタイプ → 選択が必要
- プライマリより小さい/大きいインスタンスを選べる
- ストレージ → 基本的にはプライマリと同じ設定（ストレージタイプやサイズ）が引き継がれる
- 異なるストレージを選ぶことはできない

「インスタンスタイプは選べる、ストレージは引き継ぎ固定」

#### ストレージの仕組み
- RDS は EC2 の上に DB をマネージド化したサービス
- ストレージも EBS ボリュームをベースにしている
- ストレージタイプは EBS と同じく gp2/gp3, io1/io2, HDD が選べる
- 実質、EC2 + EBS で自分で MySQL/PostgreSQL を動かすのを、AWS が隠蔽してくれているイメージ

### Aurora の場合

#### Aurora Replica 作成時
- インスタンスタイプ → 選択が必要
- Aurora の各インスタンスは独立してタイプを選べる
- Writer は db.r6g.large、Replica は db.t4g.medium のようにバラしてコスト調整可能
- ストレージ → Aurora はクラスタ共有ストレージ方式
- 1つのクラスター内で Writer も Replica も 同じストレージを共有
- なのでストレージ容量やタイプを個別に選ぶ必要はない

「インスタンスタイプだけ選ぶ、ストレージは共通で自動」

#### ストレージの仕組み
- Aurora は「EC2 + EBS」モデルではなく、分散ストレージをサービスとして提供
- SSD ベース
- 6コピーを3つのAZに自動分散
- 10GB 単位で自動スケール（最大128TB）
- EBS ではなく、専用の分散ストレージ基盤

---

## CloudFormation 変更セット

### 概要
CloudFormation スタックを更新する前に、どんな変更が行われるかを事前にプレビューできる仕組み

### 変更セットで確認できる内容

どのリソースが：
- 更新 (Modify) されるのか
- 新規作成 (Add) されるのか
- 削除 (Delete) されるのか
- 置換 (Replace) されるのか

### 他ツールとの比較
CloudFormation の変更セットは Terraform の plan と同様の仕組み

どちらも適用前に差分を確認する機能

---

## Directory Services 使い分け

### AD Connector
- オンプレ AD をそのまま使いたい
- AWS に新しい AD を立てる必要がない
- あくまで「作成したアカウント」単位のディレクトリサービス
- Organizations 全体を横断しては使えない

### AWS Managed Microsoft AD
- フルマネージドのクラウドADが必要なとき
- オンプレと信頼関係を結んでハイブリッド運用したいとき

---

## IAM Identity Center との関係

### 複数アカウントに一括で認証基盤を提供したい場合
AWS IAM Identity Center (旧 AWS SSO) + オンプレ AD 連携（AD Connector or AWS Managed Microsoft AD 経由）を使う

これなら Organizations 全アカウントでシングルサインオンが可能

### 位置づけの違い
- IAM Identity Center → 「SSOのハブ」
- AD Connector / Managed AD → 「ディレクトリサービス（ユーザー情報の源泉）」

つまり どこで認証するか vs 誰がユーザー情報を持つか の違い

---

## Directory Services 比較表

| 項目 | IAM Identity Center (旧 SSO) | AD Connector | AWS Managed Microsoft AD |
|------|-----|-----|-----|
| 主な役割 | 複数アカウント/アプリのSSO基盤 | オンプレADへのプロキシ | フルマネージドのAD（クラウド版AD） |
| ユーザー管理 | 内部ユーザー or 外部IdP連携 | オンプレADが管理 | AWSが管理（独立したADをAWSに構築） |
| 主な連携対象 | AWSアカウント、SaaSアプリ | WorkSpaces, WorkDocs, RDS for SQL Server など | WorkSpaces, RDS for SQL Server、オンプレADと信頼関係も可 |
| AWS Organizationsとの統合 | 可能（全アカウントSSO） | 不可（単一アカウントのみ） | （ディレクトリサービス単体） |
| SSO機能 | あり（マルチアカウント、SaaS含む） | なし | なし |
| ユースケース | AWS全体のSSO、権限セット管理 | オンプレADをそのまま使いたい | AWSにADを移行/クラウドでAD運用したい |

---

## IAM Identity Center の特徴

### AWS Organizations と統合
複数アカウントをまとめて管理し、アカウント横断でのログインを簡単にできる

### 権限管理（Permission Set）
- 単にログインするだけじゃなく、「このユーザーは本番アカウントでは ReadOnly、開発アカウントでは Admin」みたいに きめ細かい権限を付与できる
- IAM ロールを個別に管理する代わりに、ポリシーをテンプレート化して割り当て可能

### 外部IdPとの連携
- オンプレADやOktaなど外部IdPと連携して認証を任せられる
- ユーザー管理を AWS 内でやる必要もない

### SaaSアプリへのSSO
- AWS だけじゃなく Salesforce, Office365, Slack などの SaaS にも SSO 可能
- つまり AWSアカウント＋外部アプリのSSOハブ

---

## Directory Services 選択指針

### 複数（マルチアカウント・マルチAD・SaaS連携）
IAM Identity Center

### オンプレADをそのまま
AD Connector

### クラウドでADを持ちたい/移行したい
Managed AD

---

## HTTPS通信における証明書配置

### CloudFront → ALB → EC2 の例

#### CloudFront → ALB
- プロトコル: 通常は HTTPS (443) を推奨
- ACM で発行した証明書を ALB にアタッチすることで、暗号化通信が可能

#### ALB → EC2
ここは要件次第
- セキュリティ要件が厳しい → HTTPS
- VPC 内だけで閉じていて OK → HTTP (暗号化なしでも可)

### ACM の特徴
- ALB、CloudFront、API Gateway、ELB、などに直接アタッチできる
- 自動更新なので運用も楽

---

## EC2の鍵ペア

### EC2インスタンスの秘密鍵とは
EC2 のログインに使う SSH 鍵ペアの秘密鍵ファイル（.pem） のこと

### 鍵ペアとは
鍵のセット
- 公開鍵 (Public Key) → AWS 側に保存され、EC2インスタンスの ~/.ssh/authorized_keys に登録される
- 秘密鍵 (Private Key) → ユーザーが .pem ファイルとしてダウンロードして保持

この 2つがペアになって SSH公開鍵認証 に使われる

---

## DynamoDB のパーティション問題

### 問題
特定のデータ領域にアクセスが集中 → DynamoDB の パーティションキーが偏っている

### DynamoDB の仕組み
- データは パーティションキー に基づいて複数パーティションに分散配置される
- アクセスが特定パーティションに集中するとスループットが偏り、遅延やスロットリングが発生

---

## RDS データ変更検知方法

### 基本的な制限
RDS にはデータが追加されたイベント通知は標準では存在しない

### RDSでデータ変更を検知する方法

#### 1. アプリケーション側でイベント発行 (推奨)
- アプリがINSERT/UPDATEを実行した後に SNS / SQS / Kinesis にもイベントを送信
- 一番シンプルでよく使われる方法

#### 2. RDS MySQL/PostgreSQL の binlog / WAL を使用
- AWS DMS (Database Migration Service) の Change Data Capture (CDC) 機能を利用
- RDS の binlog (MySQL) や WAL (Postgres) を監視
- 変更を Kinesis / S3 / Redshift / Lambda にストリーム転送可能
- アプリを改修せずに、DBの変更イベントをキャッチ可能

#### 3. データベースのネイティブ機能を利用
- MySQL: トリガー (AFTER INSERT/UPDATE) を作り、専用の監査テーブルや外部APIに書き出し
- PostgreSQL: NOTIFY/LISTEN 機能を利用してアプリがサブスクライブ
- ただし RDS では OS レベルアクセスが制限されるため、用途は限定的

#### 4. Aurora限定機能
- Aurora なら Auroraマルチマスターや Auroraストリームを活用
- 変更イベントを Kinesis に流すことが可能（特定エンジン機能）

---

## Lambda から RDS にアクセスする方法

### データベース接続ライブラリをLambdaに組み込む
- MySQL なら mysql-connector-python や pymysql
- PostgreSQL なら psycopg2

### Lambda と RDS を同じ VPC に配置
Lambda 関数に VPC設定を有効化して、RDS のサブネット/セキュリティグループにアクセスできるようにする

### 認証情報を安全に管理
- DB ユーザー名・パスワードは Secrets Manager で管理
- Lambda から Secrets Manager API を呼び出して取得する

### 処理フロー例
1. API Gateway → Lambda
2. Lambda が RDS に接続して SELECT文で製品データ取得
3. 結果を JSON で返す

### 注意点
- Lambda の実行時間上限は 15分 → 長時間クエリは不向き
- 高頻度アクセスなら RDS Proxy を使うと接続効率がよい
- 読み取り専用なら Aurora/RDS の リードレプリカ を使うのもアリ

---

## RDS イベント通知の範囲

### RDS イベントサブスクリプション 機能で取れるもの
- インスタンスの起動/停止/削除
- スナップショット作成/削除
- バックアップ成功/失敗
- フェイルオーバー開始/完了
- パラメータ変更反映
- セキュリティパッチ適用

これは 「DBのライフサイクルやメンテナンスの通知」

### 存在しないもの
- INSERT / UPDATE / DELETE といった SQLのデータ更新イベント
- 「テーブルに新しいデータが追加された」といった アプリケーションレベルの通知

これは RDS標準機能では提供されない
代わりに アプリ改修 or DMSのCDC (Change Data Capture) を使う

---

## RDS Proxy

### 概要
Amazon RDS Proxy は、RDS（MySQL、PostgreSQL、Aurora）向けの フルマネージド接続プールサービス

### 背景問題
RDS は「DBコネクションの張り直しコスト」が高い

Lambda や Fargate のように短命なコンテナ／関数が高頻度で実行されると、毎回「TCP接続 → ハンドシェイク → 認証」を行うことになり、
- レイテンシ増加
- DB の同時接続数上限に到達
- スパイク時に接続エラー
が起きやすくなる

### RDS Proxy の役割

#### 接続プール
- 事前に DB への接続を確立して保持しておく
- Lambda などのクライアントは Proxy に接続するだけで、既存のコネクションを再利用できる

#### スケーラビリティ
- アクセスが急増しても、RDS Proxy が効率的に接続をさばいてくれる
- DB本体に無駄な接続が殺到しない

#### フェイルオーバー高速化
RDS Multi-AZ や Aurora フェイルオーバー時に、接続を Proxy が吸収して切替をスムーズにしてくれる

#### セキュリティ
- Secrets Manager と統合 → DBの認証情報を安全に管理
- Lambda 側にパスワードを直書きしなくてもよい

---

## AWS IoT Core

### 概要
AWS IoT Coreは、複数のIoTデバイスを一元的に管理し、制御できるサービス

---

## AWS Global Accelerator

### 概要
「グローバルに高速＆安定した入口（アクセスポイント）」を提供するサービス

### アタッチ先（エンドポイント）
Global Accelerator では「エンドポイントグループ」を作って、そこに以下を登録できる：
- Application Load Balancer (ALB)
- Network Load Balancer (NLB)
- EC2 インスタンス（パブリックIP付き）
- Elastic IP アドレス（固定IPとして使える）

### 他サービスとの比較
- CloudFront は「HTTP/HTTPS のコンテンツ配信」
- Global Accelerator は「TCP/UDP アプリ全般をグローバルに最適化」

### 特徴
- Anycast IPを提供するので、クライアントからは「同じIP」で世界中からアクセス
- 普通は ALB や NLB にアタッチして使うのがベストプラクティス

「グローバルに低レイテンシ保証」と来たら → Global Accelerator

---

## AWS PrivateLink

### AWS PrivateLink (VPC Endpoint Service) 
サードパーティーが VPCエンドポイントサービス としてAPIを公開していれば、
自社VPCに Interface VPC Endpoint を作成してプライベートアクセスできる

通信は AWS内部ネットワークを通過するため、パブリックインターネットを経由しない

サードパーティーSaaSとの接続で一番よく使われる

### 使うコンポーネント

#### VPC エンドポイントサービス (Provider側)
サードパーティーや別アカウントのサービス提供側が「これをプライベート公開する」と設定する

#### Interface VPC Endpoint (Consumer側)
利用する側（今回のEC2のあるVPC）がこれを作成して接続する
ENI (Elastic Network Interface) が VPC サブネットに作成され、そこ経由でサービスにアクセス

### エンドポイントの種類

#### Interface エンドポイント
- ENI を経由する
- PrivateLink で使うのはこれ
- サードパーティーSaaS / AWSサービスのプライベート接続に使う

#### Gateway エンドポイント
- S3 / DynamoDB 専用
- ルートテーブルにエントリを追加するだけ
- ENIは作られない

---

## Direct Connect / Site-to-Site VPN の役割

### Direct Connect (DX)
- オンプレ ↔ AWS を 専用線でつなぐサービス
- 大容量・低レイテンシ・安定性に優れる

### Site-to-Site VPN
- オンプレ ↔ AWS を IPSec VPN トンネルでつなぐサービス
- インターネット経由だけど暗号化される

どちらも「オンプレ環境とAWSをつなぐサービス」

AWS上にきたらこの２つは候補から外される

---

## DynamoDB トランザクション

### 概要
複数のアイテムや複数のテーブルに対して、すべての操作をアトミックに（全部成功か全部失敗か）実行できる機能

### 特性
ACID 特性 を保証

### API
- 複数の書き込みをまとめて処理 → TransactWriteItems
- 複数の読み込みをまとめて処理 → TransactGetItems

---

## セキュリティグループのSSH設定

### 重要ポイント
セキュリティグループにおけるSSH接続の際はプロトコルタイプはUDPではなく、TCPのポートレンジを設定することが必要

### SSH の基本仕様
- プロトコル: TCP
- ポート番号: 22
- UDPは使用しない（UDPはDNSやDHCPなどに使用）

---

## TCP vs UDP 比較

### TCP (Transmission Control Protocol)

#### 特徴
- コネクション型（接続を確立してから通信）
- 信頼性が高い（パケットの順序保証・再送制御あり）
- エラーチェックやフロー制御も実施

#### 使用場面
信頼性が必須な通信

#### 例
SSH (22), HTTP/HTTPS (80/443), FTP (21), SMTP (25), MySQL (3306)

### UDP (User Datagram Protocol)

#### 特徴
- コネクションレス型（事前の接続確立なしで送信）
- 信頼性が低い（パケット順序保証なし・再送制御なし）
- その分オーバーヘッドが小さくて高速

#### 使用場面
- リアルタイム性が重要な通信
- 多少のパケットロスを許容できるケース

#### 例
DNS (53), DHCP (67/68), VoIP, 動画ストリーミング, ゲーム通信

### まとめ
- TCP = 信頼性重視（正確に届けたい）
- UDP = スピード重視（多少落ちても良い）
- SSH は TCP を使用