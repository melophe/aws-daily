# AWS Managed Microsoft AD

## 基本概念

AWS Managed Microsoft ADを「使う」と決めた場合:

- AWS側に専用のADが必ず作られる（＝マネージドADのディレクトリ）
- AWSが管理するドメインコントローラが複数台立つ（ユーザー側は直接RDPできない）
- これが「AWS側のAD」として存在する

## オンプレADとの連携

### 信頼関係の設定

- 信頼関係（Trust Relationship）を設定して相互認証を実現
- 双方向でも一方向でもOK

### 重要ポイント

「Managed ADを使う」と決めたら、AWS側にADは必須（勝手に作られる）

---

## AD Connector vs Managed AD

### AD Connector
- AWSにADは作らない（オンプレADに全部投げる）
- オンプレにADが必須
- AWS側にはADは作られない（ただのプロキシ）
- 認証要求はすべてオンプレADにフォワードされる
- オンプレが止まったら認証も止まる

### AWS Managed Microsoft AD
- AWSにフル機能のADが構築される（オンプレと信頼関係を結べる）
- オンプレがなくても単独で動作可能（AWS上に完全なADが立つ）
- オンプレがある場合は、信頼関係を結んでハイブリッドにできる
- FSxやWorkSpacesなど、一部のAWSサービスはこれが必須

---

## CloudWatch ダッシュボード共有の仕組み

### 公開リンクの発行

- ダッシュボードを「共有」すると、サインイン不要で誰でもアクセスできるURL を発行可能
- URLを知っている人だけが閲覧可能（認証なしの読み取り専用ビュー）

### 制御のポイント

- 共有を有効化／無効化するのは管理者権限が必要
- 必要がなくなったら「共有解除」すれば、URLはすぐ無効化される
- 書き込みや削除は当然できず、あくまで参照専用

### ユースケース

- 外部監査員に定期的にメトリクスを見せたい
- IAMユーザーやフェデレーションを作りたくない
- 一時的な公開が必要

### 注意点

- URLは「秘密リンク」的な扱いなので、もし漏れたら第三者も見られる
- 長期的に安全に運用したい場合は、IAMユーザー＋ReadOnly権限で閲覧させるのがセキュリティ的にはベター

---

## VPCエンドポイント

### ゲートウェイエンドポイント (Gateway Endpoint)

#### 対象サービス
S3 と DynamoDB 専用

#### 仕組み
- VPCに「エンドポイント」を作ると、自動的に「ルートテーブル」にエントリを追加する必要がある
- 例: S3 用なら、pl-xxxx（Prefix List ID）宛のルートが追加される
- **ルートテーブル必須**

#### ポイント
「インターネットゲートウェイを通らずに S3/DynamoDB にアクセスできる」ようにするため、ルートに経路を書く必要がある

### インターフェースエンドポイント (Interface Endpoint)

#### 概要
ENI（Elastic Network Interface）を作るタイプ

#### 対象
PrivateLink を使って多くの AWS サービスや SaaS と接続可能

#### 仕組み
- VPCサブネットに ENI が作られて、そこ経由で接続
- **ルートテーブルは不要**（そのサブネットの ENI 宛に直接トラフィックが行くため）

### まとめ

- **Gateway Endpoint** → ルートテーブル必要（S3 / DynamoDB）
- **Interface Endpoint** → ルートテーブル不要（ENI経由で通信）

---

## インスタンスプロファイルとIAMロールの関係

### IAMロール

「このリソースにはこういう権限を与える」という定義そのもの

**例**: 「S3のparcel-logsバケットにGetObject/PutObjectできる」

### インスタンスプロファイル (Instance Profile)

EC2にアタッチするための"ロールの入れ物"

- EC2は直接IAMロールを持てないので、「インスタンスプロファイル」にロールを紐づけて、それをEC2にアタッチする仕組み
- コンソールでEC2起動時に「IAMロールをアタッチ」と選ぶと、裏側では自動的にインスタンスプロファイルを使用

---

## クロスアカウントアクセス

クロスアカウントアクセスの王道は **IAMロールの信頼ポリシー + STS AssumeRole**

### シナリオ

#### アカウントDev（開発環境）
- 開発者が所属
- 開発用のEC2インスタンスがある

#### アカウントProd（本番環境）
- DynamoDBテーブル OrdersTable を保持
- このテーブルに対して読み取り専用（ReadOnly）でアクセスさせたい

### 解決策

#### 1. アカウントProdにロールを作成

**ロール名**: DynamoDBReadRole

**信頼ポリシー（Trust Policy）**:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::DEV_ACCOUNT_ID:role/DevAppRole"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```

「アカウントDevのDevAppRoleだけがこのロールを引き受け可能」と定義

**アクセス許可ポリシー（Permissions Policy）**:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:Query",
        "dynamodb:Scan"
      ],
      "Resource": "arn:aws:dynamodb:ap-northeast-1:PROD_ACCOUNT_ID:table/OrdersTable"
    }
  ]
}
```

「本番アカウントのDynamoDBテーブルを読み取り専用で使える」

#### 2. アカウントDev側でEC2にアタッチするIAMロール（DevAppRole）を作成

ポリシーで sts:AssumeRole を許可:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "sts:AssumeRole",
      "Resource": "arn:aws:iam::PROD_ACCOUNT_ID:role/DynamoDBReadRole"
    }
  ]
}
```

### 実際のアクセスの流れ

1. EC2上のアプリ（Devアカウント内）が sts:AssumeRole を呼び出す
2. 本番アカウントの DynamoDBReadRole の一時認証情報を取得
3. その認証情報で本番アカウントの DynamoDB OrdersTable を読み取り

### ポイント

- さっきの問題は「ユーザーが他アカウントのS3にアクセス」だった
- 今回は「EC2（ロール）から他アカウントのDynamoDBにアクセス」

**共通しているのは**:
1. アクセス先アカウントにロールを作る
2. 信頼ポリシーでアクセス元を許可する
3. アクセス元アカウントではAssumeRoleを許可する

### まとめ

クロスアカウントアクセスの一般形は「アクセス先でロールを用意し、アクセス元にAssumeRoleを許可する」

リソースがS3であろうとDynamoDBであろうと、この考え方は共通

---

## 人がクロスアカウントでAssumeRoleするケース

### シナリオ例

- **アカウントA（開発環境）**: 開発者ユーザーがいる
- **アカウントB（本番環境）**: 「ReadOnlyRole」というロールを作ってある
- 開発者が一時的に本番環境のReadOnlyRoleを引き受けてAWSコンソールやCLIを操作したい

### 必要な設定（2つ）

#### 1. アクセス先（アカウントB）のロールの信頼ポリシー（Trust Policy）

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::DEV_ACCOUNT_ID:user/DevUser"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```

「アカウントAのDevUserはこのロールを引き受け可能」と宣言

#### 2. アクセス元（アカウントAのIAMユーザー）のIAMポリシー

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "sts:AssumeRole",
      "Resource": "arn:aws:iam::PROD_ACCOUNT_ID:role/ReadOnlyRole"
    }
  ]
}
```

「このユーザーはsts:AssumeRoleを呼び出して、指定されたロールを引き受けてよい」と許可

### 実際の動き

開発者は AWS CLI で次のように実行:

```bash
aws sts assume-role \
  --role-arn arn:aws:iam::PROD_ACCOUNT_ID:role/ReadOnlyRole \
  --role-session-name DevUserSession
```

1. 一時的な認証情報（AccessKeyId, SecretAccessKey, SessionToken）が払い出される
2. これを環境変数にセットして使えば、その間だけ本番アカウントのReadOnlyRoleの権限で操作可能

### よくある利用シーン

- **監査員や外部委託先が一時的にアクセス**: 専用ユーザーにAssumeRoleだけ許可
- **開発者が本番に入れるのは必要最低限にしたい**: 普段はDevアカウントで作業、本番に入るときだけAssumeRole
- **セキュリティ強化**: 長期キーを避け、MFA付きでAssumeRoleさせる運用もよくある

### まとめ

- 人の場合も、EC2の場合も「2段構え（信頼ポリシー＋IAMポリシー）」が必要
- 違うのは「EC2ならインスタンスプロファイル」「人ならIAMユーザーやIdentity Centerユーザー」が元になるだけ
- AssumeRoleは「呼ぶ権利を持つ人（orロール）」と「受け入れるロール」の双方で承認が必要