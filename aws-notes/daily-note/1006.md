# PCI DSSとは

PCI DSS（Payment Card Industry Data Security Standard）は、クレジットカード業界が定めたカード情報保護の国際基準

「クレジットカード番号・取引データを安全に保存・処理・伝送できる仕組みであること」が求められる

AWSでも一部のサービスのみがPCI DSS認定を受けている

---

## AWSでPCI DSSに対応している主なサービス一覧（代表的なもの）

| カテゴリ | サービス | PCI DSS 対応 |
|---------|---------|-------------|
| コンピュート | Lambda / Fargate / EC2 / ECS / EKS | 対応 |
| ストレージ | S3 / EBS / EFS / FSx / Glacier | 対応 |
| データベース | RDS / Aurora / DynamoDB / Redshift | 対応 |
| 分析 / ETL | AWS Glue / Athena / EMR | 対応 |
| セキュリティ / IAM | KMS / IAM / CloudTrail / CloudWatch / Secrets Manager | 対応 |
| API / 通信 | API Gateway / App Mesh / ALB / CloudFront | 対応 |

---

## PCI DSSでよく出るAWS構成パターン

| 要件 | 推奨サービス |
|-----|------------|
| カード番号を保存せず、一部をマスキングして処理 | AWS Glue / Lambda（ETL処理） |
| データ暗号化 | S3 (SSE-KMS) + AWS KMS |
| アクセス制御 | IAM + S3バケットポリシー + VPC Endpoint |
| 監査ログ保持 | CloudTrail + CloudWatch Logs |
| データマスキング・ETL処理 | AWS Glue（PySpark + DataBrew） |
| フルマネージド・サーバーレス構成 | S3 + Lambda + Glue の組み合わせ |

---

## マスキングに関係する主要サービス

- AWS Glue（ETLジョブ）
- AWS Glue DataBrew
- Amazon Macie（検出目的）

この3つが「マスキング」に関係する主要サービス

---

## AWS Glue Crawler の動作フロー

```
S3バケット
   ↓
AWS Glue Crawler がスキャン
   ↓
ファイル形式や列構造を解析（CSV, JSON, Parquetなど）
   ↓
Glue Data Catalog に「テーブル定義」を作成
   ↓
Athena や Glue Job から SQLクエリ or ETL処理で利用可能
```

### 実行例

`s3://incoming/sales_2025_10.csv` があって

```csv
date, card_number, amount, store_id
2025-10-05, 4111222233334444, 1200, A001
```

Glue Crawlerをこのバケットに対して実行すると:

1. データ形式（CSV）を自動検出
2. 列名（date, card_number, amount, store_id）を抽出
3. データ型（string, string, int, string）を推定
4. Glue Data Catalogに以下のようなテーブルを登録:

| カラム名 | 型 |
|---------|---|
| date | string |
| card_number | string |
| amount | int |
| store_id | string |

---

## SAMLフェデレーション＋セッションタグ＋タグベースアクセス制御（ABAC）

これを実現する代表的な仕組み:

```
STS AssumeRole with SAML
＋
IAMポリシーに Condition: StringEquals { "aws:ResourceTag/team" : "${aws:PrincipalTag/team}" }
```

### 前提

1つのAWSアカウントを4チーム（red / blue / yellow / green）が共有

各チームには SAML経由でAssumeRole するIAMロールがある

例:
- RedRole
- BlueRole
- YellowRole
- GreenRole

### 動作イメージ

**① BlueチームのエンジニアがSSOログイン**

SAMLフェデレーションでログインするとき、IdP（例：Okta, AzureAD）が「team=Blue」という属性を渡す

それによりSTSが発行する一時クレデンシャルにセッションタグが付く:

```json
"aws:PrincipalTag": {
  "team": "Blue"
}
```

**② IAMポリシーのConditionで「teamタグが一致するリソースだけAllow」**

Blueチームのロール (BlueRole など) に以下のようなポリシーを設定:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "*",
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "aws:ResourceTag/team": "${aws:PrincipalTag/team}"
        }
      }
    }
  ]
}
```

つまり:
- セッションタグ：team=Blue
- リソースタグ：team=Blue → 一致すれば操作OK
- 違うチームのタグ（例：team=Red）→ 自動的に拒否

### 具体的な動作

| 操作 | リソースタグ | 結果 |
|-----|------------|------|
| Blueチームが自分のEC2を削除 | team=Blue | 許可される |
| BlueチームがRedチームのEC2を削除 | team=Red | 拒否される |
| Blueチームがタグなしリソースにアクセス | （タグなし） | 拒否される（条件にマッチしない） |

### ポイント

- ポリシーで「タグ一致」を見ているだけなので、リソースがどの種類でも適用可能（EC2、S3、RDSなど）
- ロールを増やしても、タグ付けルールを統一すれば管理がシンプル
- IAMロールやユーザー名に直接条件を書かなくてもよい（動的にマッチ）

---

## まとめ

| 概念 | 内容 |
|-----|------|
| セッションタグ (PrincipalTag) | SAMLフェデレーションでログインしたユーザーの属性情報（例：team=Blue） |
| リソースタグ (ResourceTag) | EC2やS3などのリソースに付けるタグ（例：team=Blue） |
| ポリシー条件 | StringEquals: {"aws:ResourceTag/team": "${aws:PrincipalTag/team}"} |
| 結果 | ロールが属するチームのタグと一致するリソースだけ操作可能 |

---

## WAF導入のベストプラクティス

WAFをいきなりBlockで適用すると、誤検知により正規ユーザーのアクセスまで遮断するリスクがある

よって 「Count（観測モード）」から始めて段階的にBlockへ移行するのが安全

### 段階導入（Count → 分析 → Block）

| フェーズ | アクション | 目的 |
|---------|-----------|------|
| ① Countモードで導入 | すべてのWAFルールをCount設定 | ユーザー影響ゼロで挙動を観測 |
| ② ログ収集・分析 | WAFログを Kinesis Data Firehose → S3 に出力し、Athena等で分析 | 誤検知（false positive）を特定 |
| ③ 除外・調整 | 不要なIPSetや条件を除外 | 精度向上・誤検知低減 |
| ④ Blockへ移行 | 安全確認後にBlockへ切替 | 本格防御を有効化 |

---

## Lambdaの動作の仕組み

Lambda関数は、リクエストが来るたびにコンテナを起動してコードを実行する。
ただし次の2つの状態がある：

| 状態 | 説明 |
|-----|------|
| ❄️ コールドスタート | 新しいLambda実行環境が作られる（起動コストあり） |
| 🔥 ウォームスタート | 以前使ったLambda環境が再利用される（高速） |

### 問題のあるコード例

```python
def handler(event, context):
    # Lambdaのハンドラー内でDB接続を確立
    conn = mysql.connector.connect(
        host="xxx.aurora.amazonaws.com",
        user="admin",
        password="***",
        database="app"
    )
    result = conn.query("SELECT * FROM users")
    conn.close()
    return result
```

この場合、リクエストが来るたびに毎回DB接続を開くことになる。
つまり同時に1000個のLambdaが動いたら → 1000接続がAuroraに突撃💥

### 解決方法：ハンドラー外で接続を初期化

次のように書くことで改善する👇

```python
# 🟢 ハンドラー外で接続を初期化
import mysql.connector

conn = mysql.connector.connect(
    host="xxx.aurora.amazonaws.com",
    user="admin",
    password="***",
    database="app"
)

def handler(event, context):
    # 🟢 すでに確立済みの接続を再利用
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users")
    result = cursor.fetchall()
    return result
```

### なぜこれで改善するのか？

Lambdaは「ウォームスタート」の場合、同じ実行環境を数分〜数十分再利用する。

🧠 ハンドラー外のコードは「初回だけ」実行される

次回以降の呼び出しではすでに確立済みのDB接続を再利用できる

結果、接続オーバーヘッドとDBへの同時接続数が大幅に減る！

| 状況 | 接続の動作 | 効果 |
|-----|----------|------|
| コールドスタート時 | 初回にDB接続を確立 | 通常通り |
| ウォームスタート時 | 既存の接続を再利用 | 接続オーバーヘッドなし・DB負荷軽減 |

### 注意点

Lambda環境はいつでも破棄される可能性がある（常に永続ではない）

だから、接続切断時の例外処理（再接続ロジック）は入れておく必要あり

高負荷時にはRDS Proxyと併用するのがベスト（接続プール＋フェイルオーバー対策）

| 対策 | 内容 | 効果 |
|-----|------|------|
| DB接続をハンドラー外で初期化 | 初回だけ接続、以降再利用 | 接続オーバーヘッド削減 |
| RDS Proxy導入 | Lambda間で接続プール共有 | 同時接続数のスパイク抑制 |

---

## Lambdaのコールドスタート問題

Lambdaは通常、リクエストが来たときに初めて実行環境（コンテナ）を起動する。
この起動には数百ミリ秒〜数秒かかることがあり、これが「コールドスタート」と呼ばれる現象。

- 特に VPC内で動くLambda（例：AuroraやRDSに接続するLambda）は起動が遅くなりやすい
- 1回起動してしばらく再利用されると「ウォームスタート」になり高速

---

## 🚀 プロビジョンド同時実行とは

AWSがあらかじめ指定した数のLambda実行環境を常にウォーム状態でキープしておく機能。
つまり：

**「いつでも即座にリクエストを処理できるよう、前もって起動済みにしておく」**

という仕組み。

### ⚙️ 仕組みイメージ

| 項目 | 通常のLambda | プロビジョンド同時実行あり |
|-----|------------|---------------------|
| 起動 | リクエストが来てからコンテナ起動 → コールドスタート発生 | 事前に起動済みのコンテナを使う → 即実行 |
| 初回呼び出し | 遅い | 毎回高速応答 |
| コスト | 安い（実行時間分だけ） | 常に起動維持する分のコストが発生 |

### 設定例

```bash
aws lambda put-provisioned-concurrency-config \
  --function-name myLambda \
  --qualifier 1 \
  --provisioned-concurrent-executions 100
```

これで、常に100個のLambda環境がウォーム状態で待機。
リクエストが一気に来ても、コールドスタートゼロで即処理される。

### コストと運用の考え方

| 項目 | 通常のLambda | Provisioned Concurrency |
|-----|------------|------------------------|
| スタート時間 | 遅い（初回数秒） | ほぼゼロ |
| コスト | 実行時間分のみ | 起動維持分も課金される |
| 適用シーン | 不定期のジョブやイベント | トラフィック予測できるAPI・Webバックエンドなど |

### 使われる典型シーン

- API Gateway 経由で呼ばれる Lambda（ユーザー体感が重要）
- Aurora や RDS に頻繁にアクセスする Lambda（接続確立が遅くなるのを防ぐ）
- 朝9時などアクセスが集中する業務アプリ

---

## Lambdaの仕組み：コンテナ再利用とは

Lambdaは呼び出されるたびに 「実行環境（コンテナ）」を起動して処理するが、
1回起動した後、その環境はしばらく破棄されずにプールされることがある。

次のリクエストが同じコンテナに割り当てられた場合、
「ウォームスタート（Warm Start）」 になり、
以前に読み込まれた変数・ライブラリ・接続などを再利用できる。

---

## Pre-Signed URLが有効な理由

Pre-Signed URLは「一時的に署名付きで認可されたIAMリクエスト」。
だからS3側から見れば、

**「匿名じゃなくて、IAM署名付きの正規リクエスト」**

として扱われる。
このため、BlockPublicAccessをONにしてもPre-Signed URLの動作は影響を受けない。

### 拒否されるアクセス例

| アクセス方法 | 結果 | 理由 |
|-----------|------|------|
| `https://s3.amazonaws.com/bucket/file.jpg` | 拒否 | 匿名アクセス（パブリックアクセス）のため |

---

## 「BlockPublicAcls」「IgnorePublicAcls」とは何か？

これは S3のバケット設定（ポリシーではなく"制御機能"）で、
ACL（アクセスコントロールリスト）経由のパブリック公開を根本的に無効化する設定。

| 設定名 | 内容 |
|-------|------|
| BlockPublicAcls | これをONにすると、新しくオブジェクトをアップロードするときに public ACL を設定できなくなる |
| IgnorePublicAcls | これをONにすると、すでに付いている public-read ACL を完全に無視（=実質的にprivate扱い）する |