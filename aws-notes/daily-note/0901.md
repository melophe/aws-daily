# AWS学習ノート - 9/01

## Lambda と SQS の連携パターン

### ① Lambda → SQS（Lambda が SQS に書き込む）

#### ユースケース
- **多いケース**: イベント駆動の分散処理

#### 例
- **API Gateway → Lambda → SQS**
  - API リクエストを受けた Lambda がメッセージを SQS に入れて、後続の非同期処理に渡す
- **ETL パイプライン**
  - Lambda が処理結果やジョブをキューに入れる

#### メリット
- 非同期化できる（Lambda は SQS に投げたらすぐ終了して良い）
- バックエンドの処理を後でまとめて並列処理できる

> Lambda → SQS のパターンはかなり多い

### ② SQS → Lambda（SQS がトリガーで Lambda が起動）

#### ユースケース
- **多いケース**: ワーカー的な使い方

#### 例
- SQS に溜まったジョブを Lambda が処理していく
- バッチ処理やメール送信、画像変換などを Lambda に任せる

#### メリット
- Lambda が自動でスケール（SQS のメッセージ数に応じて並列実行）
- バックエンドの処理を完全にイベント駆動にできる

#### 注意点
> 長時間処理や重い処理には向かないので工夫が必要（DLQ, バックオフ, バッチサイズ調整など）

## IAM 権限設定

### 1. Lambda → SQS に書き込む場合

#### 設定対象
- **Lambda 側の実行ロール** にポリシーを付与

#### 必要な権限
- **アクション**: `sqs:SendMessage`
- **リソース**: 対象のキュー ARN

```json
{
  "Effect": "Allow",
  "Action": "sqs:SendMessage",
  "Resource": "arn:aws:sqs:ap-northeast-1:123456789012:MyQueue"
}
```

> Lambda が SQS に書き込むための権限が必要

### 2. SQS → Lambda をトリガーにする場合

#### 設定対象
- **Lambda 側と SQS 側の両方** にポリシーを付与

#### (a) Lambda 実行ロール
Lambda が SQS からメッセージを処理する権限：

```json
{
  "Effect": "Allow",
  "Action": [
    "sqs:ReceiveMessage",
    "sqs:DeleteMessage",
    "sqs:GetQueueAttributes"
  ],
  "Resource": "arn:aws:sqs:ap-northeast-1:123456789012:MyQueue"
}
```

#### (b) SQS リソースポリシー
SQS が Lambda にイベントを送れるようにするため：

```json
{
  "Effect": "Allow",
  "Principal": { "Service": "lambda.amazonaws.com" },
  "Action": "sqs:SendMessage",
  "Resource": "arn:aws:sqs:ap-northeast-1:123456789012:MyQueue"
}
```

> SQS が Lambda をトリガーできるようにする許可が必要

### ✅ 権限設定まとめ

| 連携パターン | 設定内容 |
|-------------|----------|
| **Lambda → SQS** | Lambda の実行ロールに「`sqs:SendMessage`」 |
| **SQS → Lambda** | • Lambda の実行ロールに「`sqs:ReceiveMessage/DeleteMessage/GetQueueAttributes`」<br>• SQS のリソースポリシーに「`lambda.amazonaws.com` を許可」 |

## Lambda IAM ポリシーのベストプラクティス

### 基本原則

**基本的に Lambda を使うときは必ず IAM ポリシー（実行ロール）を付けるべき**

### Lambda のアクセス制御の仕組み

#### 動作原理
- Lambda は IAM ロールで AWS リソースにアクセス
- Lambda 関数自体は「どのリソースにアクセスできるか」を知らない
- 代わりに「実行ロール」を引き受けて、そのロールの権限で動作

#### 権限がない場合
ポリシーが無いと、外部サービスに一切アクセスできない

### 必要な権限の例

| アクセス先 | 必要な権限 |
|-----------|-----------|
| **S3 にファイル書き込み** | `s3:PutObject` |
| **DynamoDB に書き込み** | `dynamodb:PutItem` |
| **SQS に送信** | `sqs:SendMessage` |

> 付けていなければエラーになる

### セキュリティのベストプラクティス

#### 最小権限の原則
- **必ずつけて最小権限**にするのがベストプラクティス
- **危険**: 何も考えずに `AdministratorAccess` をつける
  - Lambda 乗っ取られたら全部のリソース操作される
- **正解**: 本当に必要なアクションだけ許可

### 推奨設定

#### 基本設定
- **最低限**: `AWSLambdaBasicExecutionRole` は付ける
- **追加**: 他の AWS リソースにアクセスするなら、その都度必要最小限のポリシーを追加

> **Lambda を使うときは必ず実行ロールを設定すべき**


## 追加学習項目

### 1. EC2 への安全なアクセス

#### ベストプラクティス
- **Systems Manager Session Manager** を使用

#### 設定方法
1. **EC2 に IAM ロールをアタッチ**
2. **信頼ポリシー**: `ec2.amazonaws.com` を信頼
3. **アクセス許可ポリシー**: `AmazonSSMManagedInstanceCore` を付与

#### メリット
- SSH 鍵不要でセキュアにリモートアクセス可能

### 2. IAM ロールとポリシーの関係

#### 2つのポリシータイプ
- **信頼ポリシー**: 「誰がこのロールを引き受けられるか」（AssumeRole）
- **アクセス許可ポリシー**: 「ロールを引き受けた後、何ができるか」

#### EC2 の場合
| ポリシータイプ | 内容 |
|---------------|------|
| **信頼ポリシー** | EC2 サービスを信頼 |
| **アクセス許可ポリシー** | SSM などの操作を許可 |

### 3. Lambda と SQS の関係

#### パターン別権限設定
| パターン | 説明 | 必要な権限 |
|----------|------|------------|
| **SQS → Lambda（トリガー）** | SQS が Lambda を呼ぶ | Lambda 側に「SQS が呼べるようにする権限」 |
| **Lambda → SQS（送信）** | Lambda からメッセージを送信 | Lambda 実行ロールに「`SQS:SendMessage`」権限 |

> どっちを使うかで、付けるポリシーが変わる

### 4. CloudFormation

#### Terraform との対応
| CloudFormation | Terraform | 説明 |
|----------------|-----------|------|
| **!Ref** | **var.** | 変数参照 |
| **Mappings** | **map** | 値のマッピング |
| **AWS::CloudFormation::Stack** | **count** | 繰り返し構築（概念の違いあり） |

### 5. ECS の動作モード

| モード | 用途 | 説明 |
|--------|------|------|
| **サービス（Service Scheduler）** | 常駐プロセス用 | Web/API サーバーなど |
| **スタンドアロンタスク** | 単発処理用 | バッチ、ジョブ |
| **スケジュールタスク** | 定期実行 | EventBridge Scheduler でスタンドアロンタスクを定期実行 |

### 6. ECS 起動タイプ

#### EC2 起動タイプ
- EC2 上でタスクを動かす
- **利用可能な割引**: Spot / RI / Savings Plans

#### Fargate 起動タイプ
- サーバーレス、EC2 管理不要
- **割引制限**: Spot 相当の仕組みは基本なし（※最近は Fargate Spot が登場）

### 7. コスト最適化オプション

#### 比較表
| オプション | 特徴 | 適用範囲 |
|------------|------|----------|
| **リザーブドインスタンス（RI）** | 古い仕組み、縛りが厳しい | EC2 専用 |
| **Compute Savings Plans** | 柔軟性高い | EC2 / Fargate / Lambda |
| **EC2 Instance Savings Plans** | 高い割引率 | EC2 専用、ファミリー＋リージョン単位 |
| **Spot インスタンス** | 格安利用、中断あり | 余剰キャパシティ活用 |

#### 選択指針
- **長期利用なら** → Savings Plans（Compute / EC2 Instance）
- **中断OKなら** → Spot

### 8. AWS Batch と Spot

#### 特徴
- **AWS Batch** = ECS/Fargate/EC2 上でジョブを自動実行
- **Spot との相性**: 良い（中断されてもリトライできるため）
- **Fargate 制限**: Spot に非対応（割引は Savings Plans 頼み）

### 9. ECS と Spot

#### 起動タイプ別対応
- **EC2 起動タイプ**: Spot を使用可能
- **Fargate 起動タイプ**: Spot なし

#### 本番環境での活用
「キャパシティプロバイダー」で Spot + オンデマンドの割合を調整

### 10. キャパシティプロバイダー

#### 機能
- ECS に「どの基盤でタスクを実行するか」を指示する仕組み

#### 設定例
- Spot 70%、オンデマンド 30%

#### メリット
- タスクが中断されても再配置されるので、Spot を本番でも使いやすい

### 11. Flink とデータフロー用語

#### 用語定義
| 用語 | 説明 |
|------|------|
| **Source** | データ入力（外部→アプリ） |
| **Operator** | アプリ内部の処理（変換、集計、フィルタ） |
| **Sink** | データ出力（アプリ→外部） |

#### Amazon Managed Service for Apache Flink
- **機能**: リアルタイム処理のためのマネージド Flink
- **活用例**: 処理結果を S3（Sink）に保存して、Athena/Redshift で分析可能

> **Flink の意味**: ドイツ語で「俊敏な、すばやい」

### 12. ネットワーク関連

#### 用語
- **Egress**: 外向き通信
- **Egress VPC**: インターネットへの出口専用 VPC

#### 機能
- NAT Gateway / Firewall を一元管理
- コスト最適化、監査強化に役立つ

### 13. AWS Global Accelerator

#### 仕組み
- 世界中のユーザーから最寄りの AWS エッジロケーションにトラフィックを吸収
- AWS のバックボーン経由で最適ルーティング

#### 特徴
- 固定 IP
- 低遅延
- 高可用性

#### CloudFront との違い
| サービス | 目的 |
|----------|------|
| **CloudFront** | CDN（キャッシュ配信） |
| **Global Accelerator** | アプリケーションそのもののトラフィックを最適化 |

## 学習まとめ

### 重要ポイント

1. **IAM ロール**: 信頼ポリシー + アクセス許可ポリシー
2. **Lambda と SQS**: どっちが呼ぶかでポリシーが変わる
3. **CloudFormation**: !Ref, Mappings = Terraform の var/map に相当
4. **ECS**: サービス = 常駐、スタンドアロンタスク = 単発、スケジュールタスク = 定期実行
5. **Savings Plans**: Compute（柔軟）/ EC2 Instance（EC2専用・高割引）
6. **Spot**: 中断あり、Batch や ECS に向く
7. **キャパシティプロバイダー**: ECS で Spot/オンデマンドを組み合わせる仕組み
8. **Flink**: Source → Operator → Sink、S3 は Sink としてよく使う
9. **Egress VPC**: インターネット出口専用 VPC
10. **Global Accelerator**: グローバルアクセスの最適化