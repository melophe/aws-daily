# AWS学習ノート - 9/01

## Lambda と SQS の連携パターン

### ① Lambda → SQS（Lambda が SQS に書き込む）

#### ユースケース
- **多いケース**: イベント駆動の分散処理

#### 例
- **API Gateway → Lambda → SQS**
  - API リクエストを受けた Lambda がメッセージを SQS に入れて、後続の非同期処理に渡す
- **ETL パイプライン**
  - Lambda が処理結果やジョブをキューに入れる

#### メリット
- 非同期化できる（Lambda は SQS に投げたらすぐ終了して良い）
- バックエンドの処理を後でまとめて並列処理できる

> Lambda → SQS のパターンはかなり多い

### ② SQS → Lambda（SQS がトリガーで Lambda が起動）

#### ユースケース
- **多いケース**: ワーカー的な使い方

#### 例
- SQS に溜まったジョブを Lambda が処理していく
- バッチ処理やメール送信、画像変換などを Lambda に任せる

#### メリット
- Lambda が自動でスケール（SQS のメッセージ数に応じて並列実行）
- バックエンドの処理を完全にイベント駆動にできる

#### 注意点
> 長時間処理や重い処理には向かないので工夫が必要（DLQ, バックオフ, バッチサイズ調整など）

## IAM 権限設定

### 1. Lambda → SQS に書き込む場合

#### 設定対象
- **Lambda 側の実行ロール** にポリシーを付与

#### 必要な権限
- **アクション**: `sqs:SendMessage`
- **リソース**: 対象のキュー ARN

```json
{
  "Effect": "Allow",
  "Action": "sqs:SendMessage",
  "Resource": "arn:aws:sqs:ap-northeast-1:123456789012:MyQueue"
}
```

> Lambda が SQS に書き込むための権限が必要

### 2. SQS → Lambda をトリガーにする場合

#### 設定対象
- **Lambda 側と SQS 側の両方** にポリシーを付与

#### (a) Lambda 実行ロール
Lambda が SQS からメッセージを処理する権限：

```json
{
  "Effect": "Allow",
  "Action": [
    "sqs:ReceiveMessage",
    "sqs:DeleteMessage",
    "sqs:GetQueueAttributes"
  ],
  "Resource": "arn:aws:sqs:ap-northeast-1:123456789012:MyQueue"
}
```

#### (b) SQS リソースポリシー
SQS が Lambda にイベントを送れるようにするため：

```json
{
  "Effect": "Allow",
  "Principal": { "Service": "lambda.amazonaws.com" },
  "Action": "sqs:SendMessage",
  "Resource": "arn:aws:sqs:ap-northeast-1:123456789012:MyQueue"
}
```

> SQS が Lambda をトリガーできるようにする許可が必要

###  権限設定まとめ

| 連携パターン | 設定内容 |
|-------------|----------|
| **Lambda → SQS** | Lambda の実行ロールに「`sqs:SendMessage`」 |
| **SQS → Lambda** | • Lambda の実行ロールに「`sqs:ReceiveMessage/DeleteMessage/GetQueueAttributes`」<br>• SQS のリソースポリシーに「`lambda.amazonaws.com` を許可」 |

## Lambda IAM ポリシーのベストプラクティス

### 基本原則

**基本的に Lambda を使うときは必ず IAM ポリシー（実行ロール）を付けるべき**

### Lambda のアクセス制御の仕組み

#### 動作原理
- Lambda は IAM ロールで AWS リソースにアクセス
- Lambda 関数自体は「どのリソースにアクセスできるか」を知らない
- 代わりに「実行ロール」を引き受けて、そのロールの権限で動作

#### 権限がない場合
ポリシーが無いと、外部サービスに一切アクセスできない

### 必要な権限の例

| アクセス先 | 必要な権限 |
|-----------|-----------|
| **S3 にファイル書き込み** | `s3:PutObject` |
| **DynamoDB に書き込み** | `dynamodb:PutItem` |
| **SQS に送信** | `sqs:SendMessage` |

> 付けていなければエラーになる

### セキュリティのベストプラクティス

#### 最小権限の原則
- **必ずつけて最小権限**にするのがベストプラクティス
- **危険**: 何も考えずに `AdministratorAccess` をつける
  - Lambda 乗っ取られたら全部のリソース操作される
- **正解**: 本当に必要なアクションだけ許可

### 推奨設定

#### 基本設定
- **最低限**: `AWSLambdaBasicExecutionRole` は付ける
- **追加**: 他の AWS リソースにアクセスするなら、その都度必要最小限のポリシーを追加

> **Lambda を使うときは必ず実行ロールを設定すべき**


## 追加学習項目

### 1. EC2 への安全なアクセス

#### ベストプラクティス
- **Systems Manager Session Manager** を使用

#### 設定方法
1. **EC2 に IAM ロールをアタッチ**
2. **信頼ポリシー**: `ec2.amazonaws.com` を信頼
3. **アクセス許可ポリシー**: `AmazonSSMManagedInstanceCore` を付与

#### メリット
- SSH 鍵不要でセキュアにリモートアクセス可能

### 2. IAM ロールとポリシーの関係

#### 2つのポリシータイプ
- **信頼ポリシー**: 「誰がこのロールを引き受けられるか」（AssumeRole）
- **アクセス許可ポリシー**: 「ロールを引き受けた後、何ができるか」

#### EC2 の場合
| ポリシータイプ | 内容 |
|---------------|------|
| **信頼ポリシー** | EC2 サービスを信頼 |
| **アクセス許可ポリシー** | SSM などの操作を許可 |

### 3. Lambda と SQS の関係

#### パターン別権限設定
| パターン | 説明 | 必要な権限 |
|----------|------|------------|
| **SQS → Lambda（トリガー）** | SQS が Lambda を呼ぶ | Lambda 側に「SQS が呼べるようにする権限」 |
| **Lambda → SQS（送信）** | Lambda からメッセージを送信 | Lambda 実行ロールに「`SQS:SendMessage`」権限 |

> どっちを使うかで、付けるポリシーが変わる

### 4. CloudFormation

#### Terraform との対応
| CloudFormation | Terraform | 説明 |
|----------------|-----------|------|
| **!Ref** | **var.** | 変数参照 |
| **Mappings** | **map** | 値のマッピング |
| **AWS::CloudFormation::Stack** | **count** | 繰り返し構築（概念の違いあり） |

### 5. ECS の動作モード

| モード | 用途 | 説明 |
|--------|------|------|
| **サービス（Service Scheduler）** | 常駐プロセス用 | Web/API サーバーなど |
| **スタンドアロンタスク** | 単発処理用 | バッチ、ジョブ |
| **スケジュールタスク** | 定期実行 | EventBridge Scheduler でスタンドアロンタスクを定期実行 |

### 6. ECS 起動タイプ

#### EC2 起動タイプ
- EC2 上でタスクを動かす
- **利用可能な割引**: Spot / RI / Savings Plans

#### Fargate 起動タイプ
- サーバーレス、EC2 管理不要
- **割引制限**: Spot 相当の仕組みは基本なし（※最近は Fargate Spot が登場）

### 7. コスト最適化オプション

#### 比較表
| オプション | 特徴 | 適用範囲 |
|------------|------|----------|
| **リザーブドインスタンス（RI）** | 古い仕組み、縛りが厳しい | EC2 専用 |
| **Compute Savings Plans** | 柔軟性高い | EC2 / Fargate / Lambda |
| **EC2 Instance Savings Plans** | 高い割引率 | EC2 専用、ファミリー＋リージョン単位 |
| **Spot インスタンス** | 格安利用、中断あり | 余剰キャパシティ活用 |

#### 選択指針
- **長期利用なら** → Savings Plans（Compute / EC2 Instance）
- **中断OKなら** → Spot

### 8. AWS Batch と Spot

#### 特徴
- **AWS Batch** = ECS/Fargate/EC2 上でジョブを自動実行
- **Spot との相性**: 良い（中断されてもリトライできるため）
- **Fargate 制限**: Spot に非対応（割引は Savings Plans 頼み）

### 9. ECS と Spot

#### 起動タイプ別対応
- **EC2 起動タイプ**: Spot を使用可能
- **Fargate 起動タイプ**: Spot なし

#### 本番環境での活用
「キャパシティプロバイダー」で Spot + オンデマンドの割合を調整

### 10. キャパシティプロバイダー

#### 機能
- ECS に「どの基盤でタスクを実行するか」を指示する仕組み

#### 設定例
- Spot 70%、オンデマンド 30%

#### メリット
- タスクが中断されても再配置されるので、Spot を本番でも使いやすい

### 11. Flink とデータフロー用語

#### 用語定義
| 用語 | 説明 |
|------|------|
| **Source** | データ入力（外部→アプリ） |
| **Operator** | アプリ内部の処理（変換、集計、フィルタ） |
| **Sink** | データ出力（アプリ→外部） |

#### Amazon Managed Service for Apache Flink
- **機能**: リアルタイム処理のためのマネージド Flink
- **活用例**: 処理結果を S3（Sink）に保存して、Athena/Redshift で分析可能

> **Flink の意味**: ドイツ語で「俊敏な、すばやい」

### 12. ネットワーク関連

#### 用語
- **Egress**: 外向き通信
- **Egress VPC**: インターネットへの出口専用 VPC

#### 機能
- NAT Gateway / Firewall を一元管理
- コスト最適化、監査強化に役立つ

### 13. AWS Global Accelerator

#### 仕組み
- 世界中のユーザーから最寄りの AWS エッジロケーションにトラフィックを吸収
- AWS のバックボーン経由で最適ルーティング

#### 特徴
- 固定 IP
- 低遅延
- 高可用性

#### CloudFront との違い
| サービス | 目的 |
|----------|------|
| **CloudFront** | CDN（キャッシュ配信） |
| **Global Accelerator** | アプリケーションそのもののトラフィックを最適化 |

## 学習まとめ

### 重要ポイント

1. **IAM ロール**: 信頼ポリシー + アクセス許可ポリシー
2. **Lambda と SQS**: どっちが呼ぶかでポリシーが変わる
3. **CloudFormation**: !Ref, Mappings = Terraform の var/map に相当
4. **ECS**: サービス = 常駐、スタンドアロンタスク = 単発、スケジュールタスク = 定期実行
5. **Savings Plans**: Compute（柔軟）/ EC2 Instance（EC2専用・高割引）
6. **Spot**: 中断あり、Batch や ECS に向く
7. **キャパシティプロバイダー**: ECS で Spot/オンデマンドを組み合わせる仕組み
8. **Flink**: Source → Operator → Sink、S3 は Sink としてよく使う
9. **Egress VPC**: インターネット出口専用 VPC
10. **Global Accelerator**: グローバルアクセスの最適化

Provisioned の意味

英語の "provision" は「用意する」「供給する」という意味。

クラウドの文脈で Provisioned と言うと、
リソースをあらかじめ固定的に確保しておく方式指す

AWS における「プロビジョンド」

例をいくつか挙げると：

EC2

「プロビジョニングする」＝ インスタンスを起動してリソースを確保すること。

起動した分のインスタンスは固定的に使い続ける。

RDS / Aurora

Provisioned Aurora =

インスタンスタイプ（例: db.r6g.large）を指定してクラスターを作る。

CPU、メモリ、I/O のキャパシティは固定。

必要に応じて手動または Auto Scaling（リードレプリカ増減）で対応。

Aurora Serverless =

ACU（Aurora Capacity Unit）を基準に、負荷に応じて自動でスケールイン/アウトする。

「固定的に確保」する必要がなく、秒単位でリソースが変動。

DynamoDB

Provisioned Capacity = 1 秒あたりの Read/Write キャパシティユニットを固定して予約。

On-Demand Capacity = リクエストに応じて自動スケール。

## AWS基礎概念

### Provisioned の意味
- **定義**: あらかじめ固定的にリソースを確保する方式
- **対義語**: Serverless（従量自動スケール）

#### Aurora の場合
| タイプ | 特徴 |
|--------|------|
| **Aurora Provisioned** | インスタンス型を指定して固定運用 |
| **Aurora Serverless** | 自動でキャパシティ調整、秒単位でスケーリング |

## オンプレ AD と AWS 認証統合

### 統合方法
- **AWS IAM Identity Center**（旧 AWS SSO）を利用
- **AWS Organizations** と統合して複数アカウントを一元管理可能
- **オンプレ AD** は AD Connector または AWS Managed Microsoft AD を使って連携

### AWS Organizations
- **機能**: 複数の AWS アカウントを一元的に作成・管理するサービス
- **前提条件**: 「すべての機能（All features）」を有効化 → SCP や一元管理が利用可能
- **主要機能**: アカウント作成、統合請求、SCP、Identity Center との統合

### IAM Identity Center と Organizations の統合
- Organizations のアカウント情報を Identity Center に同期可能
- **Permission Set**（IAM ポリシー）を作成し、ユーザー/グループに対してアカウントごとに権限を割り当て
- 外部 IdP（オンプレ AD、Azure AD、Okta など）とも連携でき、**SSO で AWS にアクセス**可能

### 料金
| サービス | 料金 |
|----------|------|
| **AWS Organizations** | 無料 |
| **IAM Identity Center** | 無料 |
| **AD Connector** | 無料 |
| **AWS Managed Microsoft AD** | 有料（Standard 約 300 USD/月〜） |

## S3 オブジェクトロック

### コンプライアンスモード
- **制限**: 保持期間中は root を含め誰も削除・変更不可
- **用途**: 法規制対応に利用

### ガバナンスモード
- **制限**: 通常ユーザーは削除不可
- **例外**: 特権ユーザー（`s3:BypassGovernanceRetention` 権限あり）は削除可能
- **用途**: 社内統制や柔軟な運用に利用

## 実践問題解説

### 1. Amazon EMR とセキュリティ

#### 要件
- ワークロードごとにアクセスできる AWS サービスを分けたい
- IMDSv2 は使わせたくない

#### 正解
- 各サービスに **インターフェイス VPC エンドポイント** を作る
- そのセキュリティグループでアクセス制御する

#### 不正解例
- ローカル FW ルールや「IMDS リクエスト無効化」を答える選択肢

### 2. CloudHSM と KMS の違い

| サービス | 特徴 |
|----------|------|
| **CloudHSM** | 専用のハードウェアセキュリティモジュール（FIPS 140-2 準拠）を使い、自分で鍵を管理 |
| **KMS** | マネージドな鍵管理サービス。AWS が HSM を裏で運用。ユーザーは API 経由で簡単に使用 |

### 3. グローバル EC サイトのトラフィック制御

#### ルーティング方式
| 方式 | 特徴 |
|------|------|
| **レイテンシルーティング** | 各ユーザーから見て「最速リージョン」に振る |
| **位置情報ルーティング** | ユーザーの国/地域ごとに固定リージョンに振る |

#### 使い分け
- **技術的に速さ重視** → レイテンシ
- **規制/契約で場所固定** → 位置情報

#### 注意点
- レイテンシルーティング単体では NG
- **ヘルスチェック + フェールオーバー** を組み合わせる必要あり

### 4. Aurora のスケーリング

#### プロビジョンド Aurora
- **識別**: 「Aurora PostgreSQL クラスター」と書かれていたら → プロビジョンド Aurora（Serverless ではない）
- **特徴**: インスタンスタイプを固定して運用
- **Auto Scaling**: リードレプリカの自動増減

#### Aurora Serverless v2
- **特徴**: ACU 単位で自動的にスケーリング

### 5. Amazon ECS とスケーリング

#### EC2 起動タイプの場合
- **タスク数スケーリング** = ECS サービス Auto Scaling
- **インスタンス数スケーリング** = EC2 Auto Scaling Group

#### Fargate 起動タイプ
- **基盤**: OS/基盤はマネージド
- **注意点**: タスク数のスケーリングは明示的に設定が必要（勝手に増えない）

#### タスク数の理解
- **定義**: タスク定義に基づいたコンテナのセット数
- **例**: 1タスク定義に3コンテナ → タスク数3 → 実コンテナ9個

### 6. EC2 のコスト最適化（通信多い場合）

#### 最適解
- **M 系の汎用インスタンス** を **クラスタープレースメントグループ** に配置

#### プレースメントグループの種類
| タイプ | 特徴 |
|--------|------|
| **Cluster** | 同じラックにまとめて低レイテンシ通信を実現 |
| **Spread** | 分散配置 |
| **Partition** | パーティション分割 |

#### 注意点
- CPG は明示的に作成して指定が必要（運任せではできない）

### 7. ルートテーブルの役割

#### 基本機能
- **「宛先CIDR → ターゲット」** のルールで通信経路を決定
- **0.0.0.0/0** = すべての宛先にマッチする「デフォルトルート」

#### サブネットの分類決定
| ルート | サブネット種別 |
|--------|---------------|
| **IGW に出るルートがある** | パブリック |
| **NAT/なし** | プライベート |

#### local ルート
- デフォルトで必ずあり、**VPC 内の通信を可能にする**

### 8. サブネット間通信

#### 同じ VPC 内
- **local があるので通信可能**
- ただし **SG と NACL で許可が必要**

#### 違う VPC 間
- **デフォルトでは不可**
- 通信方法: **VPC Peering**、**Transit Gateway**
- オンプレ経由なら **VPN / Direct Connect**

### 9. VPN / Direct Connect

#### 主要用途
- **オンプレ ↔ AWS VPC の接続**

#### 比較
| 接続方法 | 特徴 |
|----------|------|
| **VPN** | インターネット経由の暗号化トンネル。安いけど不安定 |
| **Direct Connect** | 専用線。安定・高速だが高コスト |

#### VPC 間通信
- **VPC Peering / Transit Gateway が一般的**

## 全体まとめ

### 重要ポイント

1. **ネットワーク**: サブネットはルートテーブル次第でパブリック/プライベートになる。local ルートは VPC 内通信の基礎
2. **ECS/Fargate**: タスク数のスケーリングは自分で設定必要。タスク = コンテナのまとまり
3. **Aurora**: 「プロビジョンド＝固定リソース」「Serverless＝自動調整」。試験問題では「Aurora PostgreSQL クラスター」は通常プロビジョンドを意味
4. **Route53**: レイテンシと位置情報は目的が違う。障害対応はヘルスチェックと組み合わせる
5. **VPN/DC**: オンプレと AWS の接続用。VPC 間接続は別の仕組みを使用
6. **EC2配置**: 通信多いならクラスタープレースメントグループで低レイテンシ